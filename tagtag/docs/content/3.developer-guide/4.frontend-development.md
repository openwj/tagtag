---
title: 前端开发指南
description: Tagtag 前端开发指南，包括组件开发规范、Hooks 使用指南和最佳实践。
---

Tagtag 前端基于 Vue 3 + TypeScript + Vite 开发，采用组件化和模块化的设计理念。本文档将详细介绍前端开发的规范、最佳实践和常用工具。

## 1. 技术栈

| 技术 | 版本 | 用途 |
|-----|-----|-----|
| Vue | 3.3+ | 前端框架 |
| TypeScript | 5.0+ | 类型系统 |
| Vite | 4.3+ | 构建工具 |
| Pinia | 2.0+ | 状态管理 |
| Vue Router | 4.2+ | 路由管理 |
| Ant Design Vue | 4.0+ | UI 组件库 |
| Axios | 1.5+ | HTTP 客户端 |
| ESLint | 8.40+ | 代码检查 |
| Prettier | 2.8+ | 代码格式化 |

## 2. 项目结构

前端项目采用 Monorepo 结构，位于 `tagtag-ui` 目录下。

```
tagtag-ui/
├── apps/                  # 应用目录
│   └── tagtag/            # 主应用
│       ├── src/           # 源代码
│       │   ├── api/       # API 定义
│       │   ├── assets/    # 静态资源
│       │   ├── components/# 公共组件
│       │   ├── composables/# 组合式函数
│       │   ├── hooks/     # 自定义 Hooks
│       │   ├── layouts/   # 布局组件
│       │   ├── locales/   # 国际化
│       │   ├── router/    # 路由配置
│       │   ├── store/     # 状态管理
│       │   ├── styles/    # 样式文件
│       │   ├── types/     # 类型定义
│       │   ├── utils/     # 工具函数
│       │   ├── views/     # 页面组件
│       │   ├── app.vue    # 根组件
│       │   └── main.ts    # 入口文件
│       ├── public/        # 公共资源
│       ├── index.html     # HTML 模板
│       ├── vite.config.ts # Vite 配置
│       └── tsconfig.json  # TypeScript 配置
├── packages/              # 公共包
│   ├── components/        # 公共组件库
│   └── utils/             # 公共工具库
└── pnpm-workspace.yaml    # pnpm 工作区配置
```

## 3. 组件开发规范

### 3.1 组件命名

- **文件名**：使用 PascalCase 命名，如 `FormModal.vue`
- **组件名**：与文件名保持一致，使用 PascalCase 命名
- **组件标签**：在模板中使用 kebab-case，如 `<form-modal></form-modal>`

### 3.2 组件结构

组件应遵循以下结构：

```vue
<template>
  <!-- 组件模板 -->
</template>

<script setup lang="ts">
// 组件逻辑
</script>

<style scoped>
/* 组件样式 */
</style>
```

### 3.3 组件逻辑组织

- 使用 `script setup` 语法糖，简化组件开发
- 按照以下顺序组织代码：
  1. 导入语句
  2. 组件 Props 定义
  3. Emits 定义
  4. 响应式数据定义
  5. 计算属性
  6. 生命周期钩子
  7. 方法定义
  8. 事件处理

**示例**：

```vue
<template>
  <div class="form-modal">
    <a-modal
      v-model:open="visible"
      :title="title"
      @ok="handleOk"
      @cancel="handleCancel"
    >
      <a-form :model="formData" :rules="rules" ref="formRef">
        <!-- 表单内容 -->
      </a-form>
    </a-modal>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue';
import { FormInstance } from 'ant-design-vue';

// Props 定义
const props = defineProps<{
  visible: boolean;
  title?: string;
  initialData?: any;
}>();

// Emits 定义
const emit = defineEmits<{
  (e: 'update:visible', value: boolean): void;
  (e: 'submit', data: any): void;
}>();

// 响应式数据
const formRef = ref<FormInstance | null>(null);
const formData = reactive<any>({
  // 表单字段
});

// 计算属性
const rules = computed(() => ({
  // 表单规则
}));

// 生命周期钩子
onMounted(() => {
  if (props.initialData) {
    Object.assign(formData, props.initialData);
  }
});

// 方法
const handleOk = async () => {
  if (formRef.value) {
    await formRef.value.validate();
    emit('submit', formData);
    emit('update:visible', false);
  }
};

const handleCancel = () => {
  emit('update:visible', false);
};
</script>

<style scoped>
.form-modal {
  /* 组件样式 */
}
</style>
```

### 3.4 组件通信

- **Props/Emits**：父子组件通信首选 Props/Emits
- **Provide/Inject**：祖先组件向后代组件传递数据
- **Pinia**：全局状态管理
- **Event Bus**：不推荐使用，建议使用 Pinia 替代

### 3.5 组件样式

- 使用 `scoped` 属性确保样式作用域隔离
- 采用 BEM 命名规范：`block__element--modifier`
- 避免使用 `!important`
- 使用 CSS 变量管理主题色和通用样式

**示例**：

```css
/* BEM 命名规范 */
.post-card {
  /* 块样式 */
}

.post-card__title {
  /* 元素样式 */
}

.post-card--highlight {
  /* 修饰符样式 */
}
```

## 4. Hooks 使用指南

### 4.1 自定义 Hooks 命名

- 使用 `use` 前缀命名，如 `useAuth`、`useTable`
- 文件名与 Hook 名保持一致，使用 camelCase 命名

### 4.2 常用内置 Hooks

| Hook | 用途 |
|-----|-----|
| `ref` | 创建响应式数据 |
| `reactive` | 创建响应式对象 |
| `computed` | 创建计算属性 |
| `watch` | 监听数据变化 |
| `watchEffect` | 自动监听依赖变化 |
| `onMounted` | 组件挂载后执行 |
| `onUpdated` | 组件更新后执行 |
| `onUnmounted` | 组件卸载前执行 |
| `provide` | 提供数据给后代组件 |
| `inject` | 从祖先组件获取数据 |

### 4.3 自定义 Hooks 示例

#### 4.3.1 `useAuth` Hook

用于管理用户认证状态。

```typescript
// src/hooks/useAuth.ts
import { useAuthStore } from '@/store/auth';

export function useAuth() {
  const authStore = useAuthStore();

  const isAuthenticated = computed(() => !!authStore.token);
  const userInfo = computed(() => authStore.userInfo);
  const permissions = computed(() => authStore.permissions);

  const hasPermission = (permission: string) => {
    return permissions.value.includes(permission);
  };

  const login = async (loginData: any) => {
    return authStore.login(loginData);
  };

  const logout = async () => {
    return authStore.logout();
  };

  return {
    isAuthenticated,
    userInfo,
    permissions,
    hasPermission,
    login,
    logout
  };
}
```

#### 4.3.2 `useTable` Hook

用于简化表格组件的开发。

```typescript
// src/hooks/useTable.ts
import { ref, reactive, computed } from 'vue';

export function useTable<T>(fetchData: (params: any) => Promise<any>) {
  const loading = ref(false);
  const dataSource = ref<T[]>([]);
  const total = ref(0);
  
  const pagination = reactive({
    current: 1,
    pageSize: 10,
    showSizeChanger: true,
    pageSizeOptions: ['10', '20', '50', '100'],
    showTotal: (total: number) => `共 ${total} 条数据`
  });
  
  const searchParams = reactive<any>({});
  
  const fetchTableData = async () => {
    loading.value = true;
    try {
      const params = {
        page: pagination.current,
        size: pagination.pageSize,
        ...searchParams
      };
      const result = await fetchData(params);
      dataSource.value = result.records || [];
      total.value = result.total || 0;
    } catch (error) {
      console.error('获取表格数据失败:', error);
    } finally {
      loading.value = false;
    }
  };
  
  const handleSearch = () => {
    pagination.current = 1;
    fetchTableData();
  };
  
  const handleReset = () => {
    // 重置搜索参数
    Object.keys(searchParams).forEach(key => {
      searchParams[key] = '';
    });
    pagination.current = 1;
    fetchTableData();
  };
  
  const handlePageChange = (page: number, pageSize: number) => {
    pagination.current = page;
    pagination.pageSize = pageSize;
    fetchTableData();
  };
  
  return {
    loading,
    dataSource,
    total,
    pagination,
    searchParams,
    fetchTableData,
    handleSearch,
    handleReset,
    handlePageChange
  };
}
```

### 4.4 Hooks 最佳实践

- **单一职责**：每个 Hook 只负责一个功能
- **可复用性**：设计通用的 Hook，避免业务逻辑耦合
- **类型安全**：为 Hook 添加完整的 TypeScript 类型定义
- **清理副作用**：在组件卸载时清理副作用，如定时器、事件监听等

## 5. 状态管理

### 5.1 Pinia 规范

- **Store 命名**：使用 PascalCase 命名，如 `AuthStore`
- **文件结构**：每个模块对应一个 Store 文件
- **状态定义**：使用 `state` 函数定义响应式状态
- **Action 命名**：使用 camelCase 命名，异步 Action 应返回 Promise
- **Getters 命名**：使用 camelCase 命名

**示例**：

```typescript
// src/store/auth.ts
import { defineStore } from 'pinia';
import { loginApi, logoutApi } from '@/api/core/auth';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]')
  }),
  
  getters: {
    isAuthenticated: (state) => !!state.token,
    hasPermission: (state) => (permission: string) => {
      return state.permissions.includes(permission);
    }
  },
  
  actions: {
    async login(loginData: any) {
      const result = await loginApi(loginData);
      this.token = result.token;
      this.userInfo = result.user;
      this.permissions = result.user.permissions || [];
      
      localStorage.setItem('token', this.token);
      localStorage.setItem('userInfo', JSON.stringify(this.userInfo));
      localStorage.setItem('permissions', JSON.stringify(this.permissions));
      
      return result;
    },
    
    async logout() {
      await logoutApi();
      this.clearAuth();
    },
    
    clearAuth() {
      this.token = '';
      this.userInfo = null;
      this.permissions = [];
      
      localStorage.removeItem('token');
      localStorage.removeItem('userInfo');
      localStorage.removeItem('permissions');
    }
  }
});
```

### 5.2 状态管理最佳实践

- **合理划分 Store**：按功能模块划分 Store，避免单一 Store 过大
- **避免过度使用全局状态**：只将需要全局共享的状态放入 Store
- **使用 Actions 处理异步逻辑**：所有异步操作都应放在 Actions 中
- **持久化存储**：对于需要持久化的状态，使用 localStorage 或 cookie 存储

## 6. API 请求

### 6.1 Axios 配置

前端使用 Axios 进行 API 请求，配置位于 `src/api/index.ts`。

**示例**：

```typescript
// src/api/index.ts
import axios from 'axios';
import { useAuthStore } from '@/store/auth';

const request = axios.create({
  baseURL: import.meta.env.VITE_APP_API_BASE_URL,
  timeout: 10000
});

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data;
  },
  async (error) => {
    // 错误处理逻辑
    return Promise.reject(error);
  }
);

export default request;
```

### 6.2 API 模块化

将 API 按模块划分，每个模块对应一个文件。

**示例**：

```typescript
// src/api/modules/user.ts
import request from '../index';

export const userApi = {
  // 获取用户列表
  getList: (params: any) => {
    return request.get('/users', { params });
  },
  
  // 获取用户详情
  getDetail: (id: number) => {
    return request.get(`/users/${id}`);
  },
  
  // 创建用户
  create: (data: any) => {
    return request.post('/users', data);
  },
  
  // 更新用户
  update: (data: any) => {
    return request.put('/users', data);
  },
  
  // 删除用户
  delete: (id: number) => {
    return request.delete(`/users/${id}`);
  }
};
```

### 6.3 API 调用规范

- **使用 async/await**：统一使用 async/await 处理异步请求
- **错误处理**：在调用 API 时添加 try/catch 处理错误
- **参数验证**：在调用 API 前验证参数的合法性
- **加载状态**：显示适当的加载状态，提高用户体验

## 7. 路由管理

### 7.1 路由配置

路由配置位于 `src/router` 目录下，采用模块化设计。

**示例**：

```typescript
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router';
import Layout from '@/layouts/main.vue';

const routes = [
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: {
          title: '仪表盘',
          icon: 'dashboard',
          permission: 'sys:dashboard:view'
        }
      }
    ]
  },
  {
    path: '/auth',
    component: () => import('@/layouts/auth.vue'),
    children: [
      {
        path: 'login',
        name: 'Login',
        component: () => import('@/views/auth/login.vue'),
        meta: {
          title: '登录',
          requiresAuth: false
        }
      }
    ]
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/error/404.vue')
  }
];

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
});

export default router;
```

### 7.2 路由守卫

使用路由守卫实现权限控制和页面跳转逻辑。

**示例**：

```typescript
// src/router/guard.ts
import router from './index';
import { useAuthStore } from '@/store/auth';

router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore();
  
  // 设置页面标题
  document.title = `${to.meta.title || 'Tagtag'} - 后台管理系统`;
  
  // 检查是否需要认证
  if (to.meta.requiresAuth !== false) {
    if (authStore.isAuthenticated) {
      // 已登录，检查权限
      if (to.meta.permission) {
        if (authStore.hasPermission(to.meta.permission as string)) {
          next();
        } else {
          // 无权限，跳转到403页面
          next({ path: '/403' });
        }
      } else {
        next();
      }
    } else {
      // 未登录，跳转到登录页面
      next({ path: '/auth/login', query: { redirect: to.fullPath } });
    }
  } else {
    next();
  }
});
```

## 8. 代码规范

### 8.1 ESLint 规则

前端项目使用 ESLint 进行代码检查，规则配置位于 `.eslintrc.cjs` 文件中。

主要规则：
- 缩进：使用 2 个空格
- 引号：使用单引号
- 分号：不使用分号
- 尾随逗号：使用尾随逗号
- 禁止未使用的变量
- 禁止未使用的导入

### 8.2 Prettier 配置

使用 Prettier 进行代码格式化，配置位于 `.prettierrc` 文件中。

### 8.3 提交规范

使用 Commitizen 提交代码，遵循 Angular 提交规范：

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型**：
- `feat`：新功能
- `fix`：修复 bug
- `docs`：文档更新
- `style`：代码样式更新
- `refactor`：代码重构
- `test`：测试更新
- `chore`：构建工具或依赖更新

## 9. 测试

### 9.1 单元测试

使用 Vitest 进行单元测试，测试文件位于 `__tests__` 目录下。

**示例**：

```typescript
// src/components/Button/__tests__/Button.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Button from '../Button.vue';

describe('Button Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Button Text'
      }
    });
    expect(wrapper.text()).toBe('Button Text');
  });
  
  it('should emit click event', () => {
    const wrapper = mount(Button);
    wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeTruthy();
  });
});
```

### 9.2 E2E 测试

使用 Cypress 进行端到端测试，测试文件位于 `cypress/e2e` 目录下。

## 10. 性能优化

### 10.1 组件优化

- **懒加载组件**：使用 `defineAsyncComponent` 或动态 import 懒加载组件
- **使用 `v-once`**：对于静态内容使用 `v-once` 指令
- **使用 `v-memo`**：对于频繁更新的列表使用 `v-memo` 指令
- **避免不必要的渲染**：使用 `computed` 和 `watch` 优化渲染逻辑

### 10.2 网络优化

- **HTTP 缓存**：合理设置缓存策略
- **压缩资源**：启用 Gzip 或 Brotli 压缩
- **CDN 加速**：使用 CDN 加速静态资源访问
- **减少请求次数**：合并请求，使用 HTTP/2

### 10.3 构建优化

- **代码分割**：使用 Vite 的代码分割功能
- **Tree Shaking**：移除未使用的代码
- **按需加载**：按需加载第三方库
- **预构建依赖**：使用 Vite 的依赖预构建功能

## 11. 开发工具

### 11.1 VS Code 插件

- **Volar**：Vue 3 官方扩展
- **TypeScript Vue Plugin**：TypeScript Vue 支持
- **ESLint**：代码检查
- **Prettier**：代码格式化
- **GitLens**：Git 增强
- **Ant Design Vue Helper**：Ant Design Vue 组件辅助

### 11.2 命令行工具

```bash
# 安装依赖
pnpm install

# 启动开发服务器
pnpm dev

# 构建生产版本
pnpm build

# 预览生产版本
pnpm preview

# 运行 ESLint
pnpm lint

# 运行 Prettier
pnpm format

# 运行单元测试
pnpm test:unit

# 运行 E2E 测试
pnpm test:e2e
```

## 12. 最佳实践

### 12.1 代码可读性

- **注释**：为复杂逻辑添加注释
- **命名规范**：使用有意义的变量名和函数名
- **代码结构**：合理组织代码结构，使用空行分隔不同逻辑块
- **缩进**：保持一致的缩进风格

### 12.2 可维护性

- **模块化设计**：将代码拆分为可复用的模块
- **文档**：为公共组件和函数编写文档
- **测试**：为核心功能编写测试用例
- **版本控制**：合理使用 Git，提交粒度适中

### 12.3 用户体验

- **响应式设计**：适配不同屏幕尺寸
- **加载状态**：显示适当的加载状态
- **错误处理**：友好的错误提示
- **动画效果**：适当的动画效果，提升用户体验
- **性能优化**：确保页面加载和交互流畅

## 13. 总结

本文档介绍了 Tagtag 前端开发的规范、最佳实践和常用工具。遵循这些规范可以提高代码质量、可维护性和开发效率，确保团队协作顺畅。

前端开发是一个不断演进的领域，建议开发者持续关注 Vue 3、TypeScript 等技术的最新发展，不断学习和实践新的技术和最佳实践。