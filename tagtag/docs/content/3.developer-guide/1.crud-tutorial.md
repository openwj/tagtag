---
title: 实战教程：开发 CRUD 功能
description: 从零开始开发一个完整的增删改查功能模块。
---

本教程将以开发一个简单的 **“文章管理 (Post)”** 功能为例，带您完整体验 Tagtag 的前后端开发流程。

我们将实现以下功能：
1.  文章列表的分页查询。
2.  新增文章。
3.  编辑文章。
4.  删除文章。

---

## 第一步：后端开发 (Backend)

### 1. 数据库设计

首先，在数据库中创建 `sys_post` 表。

```sql
CREATE TABLE `sys_post` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(100) NOT NULL COMMENT '文章标题',
  `content` text COMMENT '文章内容',
  `status` tinyint(4) DEFAULT 1 COMMENT '状态: 1-发布, 0-草稿',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文章表';
```

### 2. 定义契约 (Contract)

在 `tagtag-contract` 模块中定义 DTO (Data Transfer Object)。建议新建 `PostDTO.java` 和 `PostQuery.java`。

**PostDTO.java (用于新增/修改)**
```java
package dev.tagtag.contract.system.dto;

import lombok.Data;
import jakarta.validation.constraints.NotBlank;

@Data
public class PostDTO {
    private Long id;

    @NotBlank(message = "标题不能为空")
    private String title;

    private String content;

    private Integer status;
}
```

**PostQuery.java (用于查询)**
```java
package dev.tagtag.contract.system.query;

import dev.tagtag.common.model.PageQuery; // 继承基础分页类
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class PostQuery extends PageQuery {
    private String title;
    private Integer status;
}
```

### 3. 持久层实现 (Mapper & Entity)

在 `tagtag-module-system` 模块中创建实体类和 Mapper。

**PostEntity.java**
```java
package dev.tagtag.module.system.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import dev.tagtag.framework.mybatis.entity.BaseEntity; // 包含 id, createTime, updateTime
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_post")
public class PostEntity extends BaseEntity {
    private String title;
    private String content;
    private Integer status;
}
```

**PostMapper.java**
```java
package dev.tagtag.module.system.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import dev.tagtag.module.system.entity.PostEntity;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface PostMapper extends BaseMapper<PostEntity> {
}
```

### 4. 业务层实现 (Service)

**PostService.java**
```java
public interface PostService {
    PageResult<PostEntity> page(PostQuery query);
    void save(PostDTO dto);
    void update(PostDTO dto);
    void delete(List<Long> ids);
}
```

**PostServiceImpl.java**
```java
@Service
@RequiredArgsConstructor
public class PostServiceImpl implements PostService {
    private final PostMapper postMapper;

    @Override
    public PageResult<PostEntity> page(PostQuery query) {
        // 使用 MyBatis Plus 的分页插件
        Page<PostEntity> page = new Page<>(query.getPage(), query.getSize());
        LambdaQueryWrapper<PostEntity> wrapper = new LambdaQueryWrapper<PostEntity>()
                .like(StringUtils.isNotBlank(query.getTitle()), PostEntity::getTitle, query.getTitle())
                .eq(query.getStatus() != null, PostEntity::getStatus, query.getStatus())
                .orderByDesc(PostEntity::getCreateTime);
        
        return PageResult.of(postMapper.selectPage(page, wrapper));
    }

    @Override
    public void save(PostDTO dto) {
        PostEntity entity = BeanUtil.copyProperties(dto, PostEntity.class);
        postMapper.insert(entity);
    }

    @Override
    public void update(PostDTO dto) {
        PostEntity entity = BeanUtil.copyProperties(dto, PostEntity.class);
        postMapper.updateById(entity);
    }

    @Override
    public void delete(List<Long> ids) {
        postMapper.deleteBatchIds(ids);
    }
}

### 5. 控制层实现 (Controller)

```java
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/posts")
@Tag(name = "文章管理")
@RequiredArgsConstructor
public class PostController {
    
    private final PostService postService;

    @GetMapping
    @Operation(summary = "分页查询")
    @PreAuthorize("@ss.hasPermission('sys:post:query')")
    public Result<PageResult<PostEntity>> page(PostQuery query) {
        return Result.success(postService.page(query));
    }

    @PostMapping
    @Operation(summary = "新增文章")
    @OperationLog(module = "文章管理", name = "新增文章", type = OperationType.ADD)
    @PreAuthorize("@ss.hasPermission('sys:post:add')")
    public Result<Void> save(@RequestBody @Validated PostDTO dto) {
        postService.save(dto);
        return Result.success();
    }

    @PutMapping
    @Operation(summary = "更新文章")
    @OperationLog(module = "文章管理", name = "更新文章", type = OperationType.UPDATE)
    @PreAuthorize("@ss.hasPermission('sys:post:update')")
    public Result<Void> update(@RequestBody @Validated PostDTO dto) {
        postService.update(dto);
        return Result.success();
    }

    @DeleteMapping
    @Operation(summary = "删除文章")
    @OperationLog(module = "文章管理", name = "删除文章", type = OperationType.DELETE)
    @PreAuthorize("@ss.hasPermission('sys:post:delete')")
    public Result<Void> delete(@RequestBody List<Long> ids) {
        postService.delete(ids);
        return Result.success();
    }
}
```

---

## 第二步：前端开发 (Frontend)

### 1. 定义 API

在 `tagtag-ui/apps/tagtag/src/api/modules/system/post.ts` 中定义请求。

```typescript
import { request } from '@/api/request';

export function getPostPage(params: any) {
  return request.get({ url: '/posts', params });
}

export function addPost(data: any) {
  return request.post({ url: '/posts', data });
}

export function updatePost(data: any) {
  return request.put({ url: '/posts', data });
}

export function deletePost(ids: number[]) {
  return request.delete({ url: '/posts', data: ids });
}
```

### 2. 创建列表页面

创建 `tagtag-ui/apps/tagtag/src/views/modules/system/post/index.vue`。

```vue
<script setup lang="ts">
import { ref, reactive } from 'vue';
import { useTable } from '@vben/plugins/vxe-table';
import { getPostPage, deletePost, addPost, updatePost } from '@/api/modules/system/post';
import { Button, Tag, Modal } from 'ant-design-vue';
import FormModal from './FormModal.vue';

// 表格配置
const [Grid, gridApi] = useTable({
  api: getPostPage,
  columns: [
    { type: 'checkbox', width: 50 },
    { field: 'title', title: '标题' },
    { field: 'status', title: '状态', slots: { default: 'status' } },
    { field: 'createTime', title: '创建时间', width: 180 },
    { title: '操作', slots: { default: 'action' }, width: 150 },
  ],
  formConfig: {
    items: [
      { field: 'title', label: '标题', component: 'Input' },
      { 
        field: 'status', 
        label: '状态', 
        component: 'Select',
        componentProps: {
          options: [
            { label: '已发布', value: 1 },
            { label: '草稿', value: 0 }
          ]
        }
      }
    ]
  },
  toolbarConfig: {
    buttons: [
      { code: 'add', name: '新增', status: 'primary' },
      { code: 'delete', name: '删除', status: 'danger' }
    ]
  }
});

// 弹窗配置
const modalVisible = ref(false);
const modalTitle = ref('');
const formData = reactive({});
const isEdit = ref(false);

// 打开新增弹窗
function handleAdd() {
  isEdit.value = false;
  modalTitle.value = '新增文章';
  Object.assign(formData, {});
  modalVisible.value = true;
}

// 打开编辑弹窗
function handleEdit(row) {
  isEdit.value = true;
  modalTitle.value = '编辑文章';
  Object.assign(formData, row);
  modalVisible.value = true;
}

// 删除单个文章
async function handleDelete(row) {
  Modal.confirm({
    title: '确认删除',
    content: `确定要删除文章 "${row.title}" 吗？`,
    onOk: async () => {
      await deletePost([row.id]);
      gridApi.refresh();
    }
  });
}

// 批量删除
async function handleBatchDelete(ids) {
  Modal.confirm({
    title: '确认删除',
    content: `确定要删除选中的 ${ids.length} 篇文章吗？`,
    onOk: async () => {
      await deletePost(ids);
      gridApi.refresh();
    }
  });
}

// 保存文章
async function handleSave(data) {
  if (isEdit.value) {
    await updatePost(data);
  } else {
    await addPost(data);
  }
  modalVisible.value = false;
  gridApi.refresh();
}

// 监听工具栏按钮点击
function handleToolbarClick(button) {
  if (button.code === 'add') {
    handleAdd();
  } else if (button.code === 'delete') {
    const selectedRows = gridApi.getSelectedRows();
    if (selectedRows.length === 0) {
      Modal.warning({ title: '提示', content: '请选择要删除的文章' });
      return;
    }
    handleBatchDelete(selectedRows.map(row => row.id));
  }
}
</script>

<template>
  <Grid @toolbar-click="handleToolbarClick">
    <template #status="{ row }">
      <Tag :color="row.status === 1 ? 'green' : 'red'">
        {{ row.status === 1 ? '已发布' : '草稿' }}
      </Tag>
    </template>
    <template #action="{ row }">
      <Button type="link" @click="handleEdit(row)">编辑</Button>
      <Button type="link" danger @click="handleDelete(row)">删除</Button>
    </template>
  </Grid>

  <!-- 新增/编辑弹窗 -->
  <FormModal
    v-model:visible="modalVisible"
    :title="modalTitle"
    :form-data="formData"
    @save="handleSave"
  />
</template>
```

### 3. 创建表单弹窗组件

创建 `tagtag-ui/apps/tagtag/src/views/modules/system/post/FormModal.vue`。

```vue
<script setup lang="ts">
import { ref, reactive, watch } from 'vue';
import { Modal, Form, Input, Select, Switch } from 'ant-design-vue';

// Props
const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  title: {
    type: String,
    default: ''
  },
  formData: {
    type: Object,
    default: () => ({})
  }
});

// Emits
const emit = defineEmits(['update:visible', 'save']);

// 表单实例
const formRef = ref();

// 表单模型
const formModel = reactive({
  id: null,
  title: '',
  content: '',
  status: 1
});

// 监听表单数据变化
watch(
  () => props.formData,
  (newData) => {
    Object.assign(formModel, newData);
  },
  { deep: true, immediate: true }
);

// 关闭弹窗
function handleCancel() {
  emit('update:visible', false);
  formRef.value?.resetFields();
}

// 提交表单
async function handleSubmit() {
  if (!formRef.value) return;
  
  try {
    await formRef.value.validate();
    emit('save', { ...formModel });
    emit('update:visible', false);
  } catch (error) {
    console.error('表单验证失败:', error);
  }
}
</script>

<template>
  <Modal
    v-model:open="visible"
    :title="title"
    ok-text="保存"
    cancel-text="取消"
    @ok="handleSubmit"
    @cancel="handleCancel"
    width="800px"
  >
    <Form
      ref="formRef"
      :model="formModel"
      layout="vertical"
      :rules="{
        title: [{ required: true, message: '请输入文章标题', trigger: 'blur' }],
        content: [{ required: true, message: '请输入文章内容', trigger: 'blur' }]
      }"
    >
      <Form.Item name="id" hidden>
        <Input v-model:value="formModel.id" />
      </Form.Item>
      
      <Form.Item label="文章标题" name="title">
        <Input v-model:value="formModel.title" placeholder="请输入文章标题" />
      </Form.Item>
      
      <Form.Item label="文章内容" name="content">
        <Input.TextArea 
          v-model:value="formModel.content" 
          placeholder="请输入文章内容"
          rows="6"
        />
      </Form.Item>
      
      <Form.Item label="发布状态" name="status">
        <Switch 
          v-model:checked="formModel.status" 
          checked-children="已发布" 
          un-checked-children="草稿"
        />
      </Form.Item>
    </Form>
  </Modal>
</template>
```

### 3. 配置菜单

1.  启动项目，登录管理员账号。
2.  进入 **系统管理 -> 菜单管理**。
3.  新增菜单 “文章管理”，路由地址填 `/system/post`，组件路径填 `modules/system/post/index.vue`。
4.  刷新页面，即可看到新功能。

---

## 第三步：测试用例编写

### 1. 后端单元测试

为了确保代码质量和功能正确性，我们需要为后端服务编写单元测试。Tagtag 使用 JUnit 5 和 Mockito 进行单元测试。

#### 1.1 准备测试环境

首先，确保在 `pom.xml` 中添加了必要的测试依赖：

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>
```

#### 1.2 编写 Service 层测试

创建 `PostServiceImplTest.java` 文件，位于 `src/test/java` 目录下：

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(MockitoExtension.class)
class PostServiceImplTest {

    @Mock
    private PostMapper postMapper;

    @InjectMocks
    private PostServiceImpl postService;

    @Test
    void testPage() {
        // 准备测试数据
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("测试");

        // 模拟分页结果
        Page<PostEntity> page = new Page<>(1, 10);
        List<PostEntity> records = new ArrayList<>();
        records.add(new PostEntity(1L, "测试文章", "内容", 1));
        page.setRecords(records);
        page.setTotal(1);

        // 设置 Mock 行为
        when(postMapper.selectPage(any(Page.class), any(LambdaQueryWrapper.class))).thenReturn(page);

        // 执行测试
        PageResult<PostEntity> result = postService.page(query);

        // 验证结果
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("测试文章");
    }

    @Test
    void testSave() {
        // 准备测试数据
        PostDTO dto = new PostDTO();
        dto.setTitle("测试文章");
        dto.setContent("内容");
        dto.setStatus(1);

        // 设置 Mock 行为
        when(postMapper.insert(any(PostEntity.class))).thenReturn(1);

        // 执行测试
        postService.save(dto);

        // 验证结果（可以添加更多验证）
        Mockito.verify(postMapper, times(1)).insert(any(PostEntity.class));
    }

    @Test
    void testUpdate() {
        // 准备测试数据
        PostDTO dto = new PostDTO();
        dto.setId(1L);
        dto.setTitle("更新测试文章");
        dto.setContent("更新内容");
        dto.setStatus(0);

        // 设置 Mock 行为
        when(postMapper.updateById(any(PostEntity.class))).thenReturn(1);

        // 执行测试
        postService.update(dto);

        // 验证结果
        Mockito.verify(postMapper, times(1)).updateById(any(PostEntity.class));
    }

    @Test
    void testDelete() {
        // 准备测试数据
        List<Long> ids = Arrays.asList(1L, 2L, 3L);

        // 设置 Mock 行为
        when(postMapper.deleteBatchIds(ids)).thenReturn(3);

        // 执行测试
        postService.delete(ids);

        // 验证结果
        Mockito.verify(postMapper, times(1)).deleteBatchIds(ids);
    }
}
```

### 2. 前端测试

前端测试包括单元测试和集成测试，Tagtag 使用 Vitest 进行单元测试，使用 Cypress 进行 E2E 测试。

#### 2.1 编写 API 测试

创建 `post.test.ts` 文件，位于 `tagtag-ui/apps/tagtag/src/api/modules/system/__tests__` 目录下：

```typescript
import { describe, it, expect, vi } from 'vitest';
import { getPostPage, addPost, updatePost, deletePost } from '../post';
import { request } from '@/api/request';

// 模拟 request 模块
vi.mock('@/api/request', () => ({
  request: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn()
  }
}));

describe('Post API', () => {
  it('getPostPage should call request.get with correct params', async () => {
    // 准备测试数据
    const params = { page: 1, size: 10, title: 'test' };
    const mockResponse = { data: { records: [], total: 0 } };
    
    // 设置模拟返回值
    (request.get as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await getPostPage(params);
    
    // 验证结果
    expect(request.get).toHaveBeenCalledWith({ url: '/posts', params });
    expect(result).toEqual(mockResponse);
  });
  
  it('addPost should call request.post with correct data', async () => {
    // 准备测试数据
    const data = { title: 'test', content: 'test content', status: 1 };
    const mockResponse = { data: { success: true } };
    
    // 设置模拟返回值
    (request.post as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await addPost(data);
    
    // 验证结果
    expect(request.post).toHaveBeenCalledWith({ url: '/posts', data });
    expect(result).toEqual(mockResponse);
  });
  
  it('updatePost should call request.put with correct data', async () => {
    // 准备测试数据
    const data = { id: 1, title: 'updated', content: 'updated content', status: 0 };
    const mockResponse = { data: { success: true } };
    
    // 设置模拟返回值
    (request.put as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await updatePost(data);
    
    // 验证结果
    expect(request.put).toHaveBeenCalledWith({ url: '/posts', data });
    expect(result).toEqual(mockResponse);
  });
  
  it('deletePost should call request.delete with correct ids', async () => {
    // 准备测试数据
    const ids = [1, 2, 3];
    const mockResponse = { data: { success: true } };
    
    // 设置模拟返回值
    (request.delete as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await deletePost(ids);
    
    // 验证结果
    expect(request.delete).toHaveBeenCalledWith({ url: '/posts', data: ids });
    expect(result).toEqual(mockResponse);
  });
});
```

#### 2.2 编写组件测试

创建 `index.test.ts` 文件，位于 `tagtag-ui/apps/tagtag/src/views/modules/system/post/__tests__` 目录下：

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// 模拟依赖
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    // 模拟 Grid 组件
    { template: '<div></div>' },
    // 模拟 gridApi
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

describe('PostIndex Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(PostIndex);
    expect(wrapper.exists()).toBe(true);
  });
  
  it('should call handleAdd when add button is clicked', async () => {
    // 模拟 handleAdd 方法
    const handleAdd = vi.fn();
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // 触发工具栏点击事件
    await wrapper.findComponent({ name: 'Grid' }).vm.$emit('toolbar-click', { code: 'add' });
    
    // 验证 handleAdd 被调用
    // 这里可以根据实际实现添加更详细的验证
    expect(wrapper.vm.modalVisible).toBe(true);
  });
});
```

## 总结

通过以上步骤，您已经成功开发了一个包含前后端交互的完整 CRUD 模块，并编写了相应的测试用例。Tagtag 的模块化设计让这一切变得清晰且规范。

### 开发流程回顾

1. **后端开发**：
   - 数据库设计
   - 定义契约（DTO、Query）
   - 持久层实现（Entity、Mapper）
   - 业务层实现（Service）
   - 控制层实现（Controller）
   - 编写单元测试

2. **前端开发**：
   - 定义 API 请求
   - 创建列表页面
   - 创建表单弹窗组件
   - 配置菜单
   - 编写 API 测试和组件测试

3. **部署和验证**：
   - 启动前后端服务
   - 登录系统验证功能
   - 执行测试用例

通过遵循这个流程，您可以快速、高效地开发出高质量的 CRUD 功能模块。
