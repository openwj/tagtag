---
title: Authentication Module
description: Authentication and authorization module documentation, detailing JWT authentication flow.
---

The **Auth** module is responsible for user authentication, authorization, and session management in the system, implementing stateless authentication based on JWT (JSON Web Token).

## 1. Authentication Module Overview

The authentication module is the security core of the system, responsible for verifying user identities and granting access permissions. Tagtag's authentication module adopts a modern JWT authentication mechanism, implementing stateless authentication, which improves system scalability and performance.

### 1.1 Core Features

- User login and logout
- JWT token generation and verification
- Token refresh mechanism
- Permission verification
- Session management

### 1.2 Technology Stack

- **JWT**: JSON Web Token, used for stateless authentication
- **BCrypt**: Password encryption algorithm to ensure password security
- **Spring Security**: Security framework providing authentication and authorization features
- **Redis**: Used to cache token blacklist and session information

## 2. JWT Authentication Principles

### 2.1 JWT Basic Concepts

JWT (JSON Web Token) is an open standard (RFC 7519) used to securely transmit information between parties as a JSON object. JWT can be verified and trusted because it is digitally signed.

### 2.2 JWT Structure

JWT consists of three parts separated by dots (.):

- **Header**: Contains the token type and signature algorithm
- **Payload**: Contains claims, such as user ID, roles, expiration time, etc.
- **Signature**: Used to verify the integrity of the token

**Format**: `header.payload.signature`

### 2.3 JWT Workflow

1. User logs in to the system using username and password
2. Server verifies the correctness of the username and password
3. Server generates a JWT token and returns it to the client
4. Client stores the JWT token
5. Client carries the JWT token in subsequent requests
6. Server verifies the validity of the JWT token
7. Server processes the request and returns a response

### 2.4 JWT Advantages

- **Stateless**: Server does not need to store session information, improving system scalability
- **Cross-domain Support**: JWT supports cross-domain authentication, facilitating distributed system construction
- **Self-contained**: Token contains all necessary user information, reducing database queries
- **Easy Integration**: Compatible with various clients

## 3. Authentication Flow

### 3.1 Login Flow

```
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│  Client    │     │  Server    │     │  Database  │     │  Redis     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ 1. Login Request  │                  │                  │
      │────────────────▶│                  │                  │
      │                  │                  │                  │
      │                  │ 2. Verify Username/Password │      │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 3. Generate JWT Token │          │                  │
      │                  │◀────────────────│                  │
      │                  │                  │                  │
      │                  │ 4. Store Token Info │          │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │ 5. Return JWT Token │              │                  │
      │◀────────────────│                  │                  │
      │                  │                  │                  │
      │                  │                  │                  │
```

### 3.2 Request Authentication Flow

```
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│  Client    │     │  Server    │     │  Database  │     │  Redis     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ 1. Request with JWT │              │                  │
      │────────────────▶│                  │                  │
      │                  │                  │                  │
      │                  │ 2. Verify JWT Validity │          │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 3. Check Token Blacklist │        │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 4. Parse User Info │          │                  │
      │                  │◀────────────────│                  │
      │                  │                  │                  │
      │                  │ 5. Permission Check │          │                  │
      │                  │                  │                  │
      │                  │ 6. Process Request │              │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │ 7. Return Response │              │                  │
      │◀────────────────│                  │                  │
      │                  │                  │                  │
```

### 3.3 Token Refresh Flow

```
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│  Client    │     │  Server    │     │  Database  │     │  Redis     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ 1. Refresh Token Request │        │                  │
      │────────────────▶│                  │                  │
      │                  │                  │                  │
      │                  │ 2. Verify Refresh Token │        │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 3. Generate New JWT │          │                  │
      │                  │◀────────────────│                  │
      │                  │                  │                  │
      │                  │ 4. Store New Token Info │      │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │ 5. Return New JWT │              │                  │
      │◀────────────────│                  │                  │
      │                  │                  │                  │
```

## 4. Core Function Implementation

### 4.1 User Login

**Function**: Verify user identity and generate JWT token.

**Implementation Details**:

- Password verification: Use BCrypt algorithm to verify password
- Token generation: Generate access token and refresh token
- Token storage: Store token information to Redis
- Response format: Return token, user information, and permission list

**Login Request**:

```json
POST /auth/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin123"
}
```

**Login Response**:

```json
{
  "success": true,
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600,
    "user": {
      "id": 1,
      "username": "admin",
      "name": "Administrator",
      "roles": ["ROLE_ADMIN"],
      "permissions": ["sys:user:view", "sys:user:add", ...]
    }
  }
}
```

### 4.2 Token Verification

**Function**: Verify the validity of JWT tokens.

**Implementation Details**:

- Signature verification: Verify if the token signature is valid
- Expiration verification: Check if the token has expired
- Blacklist verification: Check if the token is in the blacklist
- Permission verification: Verify if the user has access permissions

**Implementation Code**:

```java
@Component
public class JwtProvider {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private long expiration;
    
    public Claims getClaimsFromToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(secret.getBytes(StandardCharsets.UTF_8))
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
    
    public boolean validateToken(String token) {
        try {
            getClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (SignatureException | MalformedJwtException | ExpiredJwtException | UnsupportedJwtException | IllegalArgumentException ex) {
            return false;
        }
    }
    
    private boolean isTokenExpired(String token) {
        Claims claims = getClaimsFromToken(token);
        Date expirationDate = claims.getExpiration();
        return expirationDate.before(new Date());
    }
}
```

### 4.3 Token Refresh

**Function**: Generate a new access token using the refresh token.

**Implementation Details**:

- Refresh token verification: Verify the validity of the refresh token
- Generate new token: Generate a new access token
- Update token information: Update token information in Redis
- Expire old token: Add the old token to the blacklist

**Refresh Request**:

```json
POST /auth/refresh
Content-Type: application/json

{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

### 4.4 User Logout

**Function**: Log out and invalidate the token.

**Implementation Details**:

- Token blacklist: Add the token to the blacklist
- Clear cache: Clear user-related cache
- Session invalidation: Invalidate the current session

**Logout Request**:

```json
POST /auth/logout
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

## 5. Core Code Structure

### 5.1 Backend Code Structure

```
tagtag-module-auth
└── src
    └── main
        ├── java
        │   └── dev
        │       └── tagtag
        │           └── module
        │               └── auth
        │                   ├── controller
        │                   │   └── AuthController.java
        │                   ├── entity
        │                   │   └── AuthUser.java
        │                   ├── service
        │                   │   ├── AuthService.java
        │                   │   └── impl
        │                   │       └── AuthServiceImpl.java
        │                   ├── util
        │                   │   ├── JwtUtil.java
        │                   │   └── PasswordUtil.java
        │                   └── vo
        │                       ├── LoginRequest.java
        │                       ├── LoginResponse.java
        │                       └── RefreshTokenRequest.java
        └── resources
            └── db
                ├── schema.sql
                └── data
                    └── init.sql
```

### 5.2 Frontend Code Structure

```
tagtag-ui/apps/tagtag/src/api/core
├── auth.ts       # Authentication-related APIs
├── captcha.ts    # Captcha-related APIs
└── index.ts      # API entry
```

## 6. Frontend Implementation

### 6.1 Login Page

**Function**: Provide user login interface, supporting username/password login and captcha login.

**Implementation Details**:

- Form validation: Verify username and password format
- Captcha support: Prevent brute force attacks
- Remember password: Optional feature, using localStorage storage
- Login state management: Use Pinia to manage login state

**Code Example**:

```vue
<script setup lang="ts">
import { ref, reactive } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '@/store/auth';
import { loginApi } from '@/api/core/auth';

const router = useRouter();
const authStore = useAuthStore();

const formData = reactive({
  username: '',
  password: '',
  captcha: '',
  rememberMe: false
});

const loading = ref(false);

async function handleLogin() {
  try {
    loading.value = true;
    const result = await loginApi(formData);
    authStore.setToken(result.token);
    authStore.setUserInfo(result.user);
    router.push('/');
  } catch (error) {
    console.error('Login failed:', error);
  } finally {
    loading.value = false;
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-form">
      <h2>Tagtag Login</h2>
      <Form :model="formData" @submit.prevent="handleLogin">
        <FormItem label="Username" required>
          <Input v-model:value="formData.username" placeholder="Please enter username" />
        </FormItem>
        <FormItem label="Password" required>
          <Input.Password v-model:value="formData.password" placeholder="Please enter password" />
        </FormItem>
        <FormItem label="Captcha" required>
          <Input v-model:value="formData.captcha" placeholder="Please enter captcha" />
          <img class="captcha-img" src="/api/captcha" @click="refreshCaptcha" />
        </FormItem>
        <FormItem>
          <Checkbox v-model:checked="formData.rememberMe">Remember me</Checkbox>
        </FormItem>
        <FormItem>
          <Button type="primary" html-type="submit" :loading="loading" block>
            Login
          </Button>
        </FormItem>
      </Form>
    </div>
  </div>
</template>
```

### 6.2 Authentication State Management

**Function**: Manage user login state, including token storage, user information storage, and permission management.

**Implementation Details**:

- Token storage: Use localStorage or cookie to store tokens
- User information caching: Cache user information to reduce request times
- Permission management: Control menu and button display based on user permissions
- Automatic token refresh: Automatically refresh tokens before expiration

**Code Example**:

```typescript
import { defineStore } from 'pinia';
import { loginApi, logoutApi, refreshTokenApi } from '@/api/core/auth';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    refreshToken: localStorage.getItem('refreshToken') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]'),
    roles: JSON.parse(localStorage.getItem('roles') || '[]')
  }),
  actions: {
    setToken(token: string) {
      this.token = token;
      localStorage.setItem('token', token);
    },
    setRefreshToken(refreshToken: string) {
      this.refreshToken = refreshToken;
      localStorage.setItem('refreshToken', refreshToken);
    },
    setUserInfo(userInfo: any) {
      this.userInfo = userInfo;
      this.permissions = userInfo.permissions || [];
      this.roles = userInfo.roles || [];
      localStorage.setItem('userInfo', JSON.stringify(userInfo));
      localStorage.setItem('permissions', JSON.stringify(this.permissions));
      localStorage.setItem('roles', JSON.stringify(this.roles));
    },
    async login(loginData: any) {
      const result = await loginApi(loginData);
      this.setToken(result.token);
      this.setRefreshToken(result.refreshToken);
      this.setUserInfo(result.user);
      return result;
    },
    async logout() {
      await logoutApi();
      this.clearAuth();
    },
    async refreshToken() {
      const result = await refreshTokenApi({ refreshToken: this.refreshToken });
      this.setToken(result.token);
      this.setRefreshToken(result.refreshToken);
      return result;
    },
    clearAuth() {
      this.token = '';
      this.refreshToken = '';
      this.userInfo = null;
      this.permissions = [];
      this.roles = [];
      localStorage.removeItem('token');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('userInfo');
      localStorage.removeItem('permissions');
      localStorage.removeItem('roles');
    }
  }
});
```

### 6.3 Request Interceptor

**Function**: Automatically carry JWT tokens in requests, handling token expiration and refresh.

**Implementation Details**:

- Automatically add tokens: Add Authorization header to request headers
- Token expiration handling: Catch 401 errors and attempt to refresh tokens
- Refresh token failure: Redirect to login page

**Code Example**:

```typescript
import axios from 'axios';
import { useAuthStore } from '@/store/auth';

const request = axios.create({
  baseURL: import.meta.env.VITE_APP_API_BASE_URL,
  timeout: 10000
});

// Request interceptor
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
request.interceptors.response.use(
  (response) => {
    return response.data;
  },
  async (error) => {
    const authStore = useAuthStore();
    const originalRequest = error.config;
    
    // Handle 401 error
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Attempt to refresh token
        await authStore.refreshToken();
        // Retry request with new token
        originalRequest.headers.Authorization = `Bearer ${authStore.token}`;
        return request(originalRequest);
      } catch (refreshError) {
        // Refresh token failed, redirect to login page
        authStore.clearAuth();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default request;
```

## 7. API Reference

| Method | Endpoint | Description |
| :--- | :--- | :--- |
| POST | `/auth/login` | User login |
| POST | `/auth/logout` | User logout |
| POST | `/auth/refresh` | Refresh token |
| GET | `/auth/me` | Get current user info |
| GET | `/auth/permissions` | Get current user permissions |
| GET | `/auth/roles` | Get current user roles |
| GET | `/captcha` | Get captcha |

## 8. Best Practices

### 8.1 Security Recommendations

- **Use HTTPS**: Use HTTPS protocol in production environment to ensure data transmission security
- **Strong Password Policy**: Force users to use strong passwords and change them regularly
- **Token Expiration Time**: Set reasonable token expiration time to reduce risks
- **Refresh Token Mechanism**: Implement refresh token mechanism to improve user experience
- **Token Blacklist**: Implement token blacklist to support active token invalidation
- **Prevent CSRF Attacks**: Implement CSRF protection mechanism
- **Prevent XSS Attacks**: Escape user input to prevent XSS attacks

### 8.2 Performance Optimization

- **Token Caching**: Cache tokens to reduce database queries
- **Reduce Token Size**: Only include necessary information in tokens
- **Asynchronous Verification**: Verify tokens asynchronously to improve system performance
- **Batch Permission Check**: Check permissions in batches to reduce request times

### 8.3 Scalability

- **Modular Design**: Separate authentication module from business modules for easy extension
- **Support Multiple Authentication Methods**: Support username/password login, SMS login, third-party login, etc.
- **Support Multi-tenant**: Support multi-tenant authentication
- **Support OAuth 2.0**: Support OAuth 2.0 protocol

## 9. Extension Suggestions

### 9.1 Support Multiple Login Methods

- **SMS Login**: Support SMS verification code login
- **Email Login**: Support email verification code login
- **Third-party Login**: Support WeChat, QQ, GitHub and other third-party logins
- **Biometric Login**: Support fingerprint, facial recognition and other biometric logins

### 9.2 Enhance Security Mechanisms

- **Multi-factor Authentication**: Support multi-factor authentication to improve security
- **Risk Control**: Implement login risk control to prevent brute force attacks
- **Audit Logs**: Record authentication-related audit logs
- **Anomaly Detection**: Detect abnormal login behaviors

### 9.3 Support SSO

Implement Single Sign-On (SSO) to support seamless login between multiple systems.

### 9.4 Support JWT Extensions

- **Support JWT Extension Claims**: Support custom claims
- **Support JWT Encryption**: Support JWT encryption to improve security
- **Support JWT Revocation**: Support JWT revocation mechanism

## 10. Summary

The authentication module is the security core of the Tagtag system, implementing stateless authentication mechanism based on JWT. This module provides complete authentication functions, including user login, token verification, token refresh, and user logout.

Through the authentication module, the system implements a unified identity verification and authorization mechanism, ensuring that only authorized users can access system resources. At the same time, the authentication module supports multiple extension methods, which can be flexibly extended according to business needs.

The design and implementation of the authentication module follow the principles of security, performance, and scalability, providing reliable security guarantees for the system.