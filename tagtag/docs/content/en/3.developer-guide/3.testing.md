---
title: Testing Guide
description: Testing guide for Tagtag project, including unit testing, integration testing, and API testing.
---

# Testing Guide

Testing is an important means to ensure software quality. Tagtag project adopts a multi-layered testing strategy, including unit testing, integration testing, and API testing. This document will detail the testing methods, tools, and best practices for the Tagtag project.

## 1. Testing Overview

### 1.1 Testing Layers

The testing in Tagtag project is divided into the following layers:

| Test Type | Test Object | Test Scope | Execution Speed | Dependency |
|-----------|-------------|------------|----------------|------------|
| Unit Testing | Single class/function | Minimum unit | Fast | Low |
| Integration Testing | Multiple modules | Module interaction | Medium | Medium |
| API Testing | REST API | Interface level | Medium | High |
| E2E Testing | Entire application | End-to-end flow | Slow | High |

### 1.2 Testing Objectives

- **Ensure functional correctness**: Verify that the code implements the expected functionality
- **Improve code quality**: Discover potential problems and defects through testing
- **Enhance code maintainability**: Tests can serve as documentation for the code, facilitating subsequent maintenance
- **Support continuous integration**: Automated testing is the foundation of continuous integration
- **Reduce regression issues**: Prevent introducing new issues when modifying code

## 2. Backend Testing

Tagtag backend is developed using Java language and uses JUnit 5 and Mockito for testing.

### 2.1 Unit Testing

Unit testing is the testing of a single class or function to verify its behavior in an isolated environment.

#### 2.1.1 Testing Tools

- **JUnit 5**: Java unit testing framework
- **Mockito**: Java mocking framework used to mock dependent objects
- **AssertJ**: Fluent assertion library that provides a better assertion experience

#### 2.1.2 Testing Structure

Unit test files are usually placed in the same package as the tested class, located in the `src/test/java` directory.

```
src
└── main
    └── java
        └── dev
            └── tagtag
                └── module
                    └── system
                        └── service
                            └── impl
                                └── PostServiceImpl.java
└── test
    └── java
        └── dev
            └── tagtag
                └── module
                    └── system
                        └── service
                            └── impl
                                └── PostServiceImplTest.java
```

#### 2.1.3 Testing Example

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(MockitoExtension.class)
class PostServiceImplTest {

    @Mock
    private PostMapper postMapper;

    @InjectMocks
    private PostServiceImpl postService;

    @Test
    void testPage() {
        // Prepare test data
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("test");

        // Mock pagination result
        Page<PostEntity> page = new Page<>(1, 10);
        List<PostEntity> records = new ArrayList<>();
        records.add(new PostEntity(1L, "Test Post", "Content", 1));
        page.setRecords(records);
        page.setTotal(1);

        // Set Mock behavior
        when(postMapper.selectPage(any(Page.class), any(LambdaQueryWrapper.class))).thenReturn(page);

        // Execute test
        PageResult<PostEntity> result = postService.page(query);

        // Verify result
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("Test Post");
    }
}
```

#### 2.1.4 Testing Best Practices

- **Test single method**: Each test method should test only one functional point
- **Use meaningful test names**: Test names should describe the functionality and expected result being tested
- **Isolate dependencies with Mocks**: Use Mockito to mock external dependencies, avoiding test interference from external factors
- **Test boundary conditions**: Test null values, boundary values, exception cases, etc.
- **Keep tests concise**: Test code should be concise, clear, and easy to understand

### 2.2 Integration Testing

Integration testing is the testing of multiple modules to verify that the interaction between modules is correct.

#### 2.2.1 Testing Tools

- **Spring Boot Test**: Spring Boot integration testing framework
- **TestContainers**: Provides lightweight containerized testing environments
- **H2 Database**: In-memory database used for testing database operations

#### 2.2.2 Testing Structure

Integration test files are usually placed in the same directory as unit tests, but require the `@SpringBootTest` annotation.

#### 2.2.3 Testing Example

```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Transactional
class PostServiceIntegrationTest {

    @Autowired
    private PostService postService;

    @Autowired
    private PostMapper postMapper;

    @Test
    void testSaveAndGetPost() {
        // Prepare test data
        PostDTO postDTO = new PostDTO();
        postDTO.setTitle("Integration Test Post");
        postDTO.setContent("Integration Test Content");
        postDTO.setStatus(1);

        // Save post
        postService.save(postDTO);

        // Verify post has been saved
        List<PostEntity> posts = postMapper.selectList(null);
        assertThat(posts).hasSize(1);
        assertThat(posts.get(0).getTitle()).isEqualTo("Integration Test Post");

        // Pagination query posts
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("Integration Test");

        PageResult<PostEntity> result = postService.page(query);
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("Integration Test Post");
    }
}
```

#### 2.2.4 Testing Best Practices

- **Test real dependency relationships**: Integration tests should use real dependency relationships, not Mocks
- **Use in-memory database**: Use H2 or other in-memory databases to avoid affecting real databases
- **Use transaction management**: Use the `@Transactional` annotation to ensure test data does not contaminate the database
- **Test core business processes**: Integration tests should test core business processes, not individual functional points

### 2.3 API Testing

API testing is the testing of REST APIs to verify the correctness and reliability of interfaces.

#### 2.3.1 Testing Tools

- **Spring Boot Test**: Provides `TestRestTemplate` and `WebTestClient` for API testing
- **JUnit 5**: Testing framework
- **AssertJ**: Assertion library

#### 2.3.2 Testing Example

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PostControllerApiTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void testPagePosts() {
        // Prepare test data
        PostDTO postDTO = new PostDTO();
        postDTO.setTitle("API Test Post");
        postDTO.setContent("API Test Content");
        postDTO.setStatus(1);

        // Save post
        restTemplate.postForEntity("/posts", postDTO, Void.class);

        // Test pagination query
        ResponseEntity<Result<PageResult<PostDTO>>> response = restTemplate.getForEntity(
                "/posts?page=1&size=10&title=API Test",
                new ParameterizedTypeReference<Result<PageResult<PostDTO>>>() {}
        );

        // Verify result
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        Result<PageResult<PostDTO>> result = response.getBody();
        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData().getTotal()).isEqualTo(1);
        assertThat(result.getData().getRecords()).hasSize(1);
        assertThat(result.getData().getRecords().get(0).getTitle()).isEqualTo("API Test Post");
    }
}
```

#### 2.3.3 Testing Best Practices

- **Test all HTTP methods**: Test GET, POST, PUT, DELETE, etc. all HTTP methods
- **Test different request parameters**: Test different query parameters, path parameters, and request bodies
- **Test error cases**: Test invalid parameters, insufficient permissions, and other error cases
- **Verify response format**: Verify response status codes, headers, and response body format
- **Use JSON Schema validation**: Use JSON Schema to validate the structure of the response body

## 3. Frontend Testing

Tagtag frontend is developed using TypeScript language and uses Vitest and Cypress for testing.

### 3.1 Unit Testing

Frontend unit testing is the testing of a single component or function to verify its behavior in an isolated environment.

#### 3.1.1 Testing Tools

- **Vitest**: Modern frontend testing framework based on Vite
- **Vue Test Utils**: Vue component testing library
- **jsdom**: Browser environment simulation

#### 3.1.2 Testing Structure

Frontend unit test files are usually placed in the same directory as the tested component, using `.test.ts` or `.spec.ts` suffix.

```
src
└── views
    └── modules
        └── system
            └── post
                ├── index.vue
                ├── FormModal.vue
                └── __tests__
                    ├── index.test.ts
                    └── FormModal.test.ts
```

#### 3.1.3 Testing Example

```typescript
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// Mock dependencies
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    // Mock Grid component
    { template: '<div></div>' },
    // Mock gridApi
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

describe('PostIndex Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(PostIndex);
    expect(wrapper.exists()).toBe(true);
  });
  
  it('should open modal when add button is clicked', async () => {
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // Trigger toolbar click event
    await wrapper.findComponent({ name: 'Grid' }).vm.$emit('toolbar-click', { code: 'add' });
    
    // Verify modal has opened
    expect(wrapper.vm.modalVisible).toBe(true);
    expect(wrapper.vm.modalTitle).toBe('Add Post');
  });
});
```

#### 3.1.4 Testing Best Practices

- **Test component rendering**: Verify that components can render correctly
- **Test component interaction**: Test component responses to user interactions
- **Test props and emits**: Verify that component props and emits work correctly
- **Mock external dependencies**: Use vi.mock to mock external dependencies
- **Test computed properties and watch**: Verify the behavior of computed properties and watch

### 3.2 Integration Testing

Frontend integration testing is the testing of multiple components to verify that the interaction between components is correct.

#### 3.2.1 Testing Tools

- **Vitest**: Same testing framework as unit tests
- **Vue Test Utils**: Vue component testing library
- **Mock Service Worker (MSW)**: API mocking library used to mock backend APIs

#### 3.2.2 Testing Example

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { setupServer } from 'msw/node';
import { rest } from 'msw';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// Mock dependencies
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

// Set up MSW server
const server = setupServer(
  rest.get('/api/posts', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        success: true,
        data: {
          records: [
            { id: 1, title: 'Test Post', content: 'Test Content', status: 1, createTime: new Date().toISOString() }
          ],
          total: 1
        }
      })
    );
  }),
  rest.post('/api/posts', (req, res, ctx) => {
    return res(ctx.status(200), ctx.json({ success: true }));
  })
);

// Start server
beforeAll(() => server.listen());
// Close server
afterAll(() => server.close());
// Reset request handlers
afterEach(() => server.resetHandlers());

describe('PostIndex Integration Test', () => {
  it('should load posts correctly', async () => {
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // Mock gridApi.refresh() to trigger data loading
    const [_, gridApi] = useTable();
    await gridApi.refresh();
    
    // Verify data has been loaded
    // More detailed verification can be added based on actual implementation
    expect(gridApi.refresh).toHaveBeenCalled();
  });
});
```

#### 3.2.3 Testing Best Practices

- **Test component interaction**: Verify communication and data transfer between components
- **Mock backend API**: Use MSW to mock backend APIs, avoiding dependency on real backend
- **Test complete user flows**: Test complete flows from user input to data update
- **Verify state management**: Verify the behavior of Pinia state management

### 3.3 E2E Testing

E2E (End-to-End) testing is the testing of the entire application to verify end-to-end user flows.

#### 3.3.1 Testing Tools

- **Cypress**: Modern E2E testing framework
- **Chrome/Firefox**: Real browser environment

#### 3.3.2 Testing Structure

E2E test files are usually placed in the `cypress/e2e` directory, using `.cy.ts` suffix.

#### 3.3.3 Testing Example

```typescript
describe('Post Management', () => {
  beforeEach(() => {
    // Login to the system
    cy.visit('/');
    cy.get('input[name="username"]').type('admin');
    cy.get('input[name="password"]').type('admin123');
    cy.get('button[type="submit"]').click();
    
    // Navigate to post management page
    cy.visit('/system/post');
  });
  
  it('should add a new post', () => {
    // Click add button
    cy.get('button:contains("Add")').click();
    
    // Fill out form
    cy.get('input[placeholder="Please enter post title"]').type('E2E Test Post');
    cy.get('textarea[placeholder="Please enter post content"]').type('E2E Test Content');
    cy.get('button:contains("Save")').click();
    
    // Verify post has been added
    cy.get('.ant-table-row').should('contain', 'E2E Test Post');
  });
  
  it('should edit a post', () => {
    // Click edit button
    cy.get('.ant-table-row').first().find('a:contains("Edit")').click();
    
    // Modify form
    cy.get('input[placeholder="Please enter post title"]').clear().type('Modified E2E Test Post');
    cy.get('button:contains("Save")').click();
    
    // Verify post has been modified
    cy.get('.ant-table-row').should('contain', 'Modified E2E Test Post');
  });
  
  it('should delete a post', () => {
    // Click delete button
    cy.get('.ant-table-row').first().find('a:contains("Delete")').click();
    
    // Confirm deletion
    cy.get('.ant-modal-confirm-btns').find('button:contains("Confirm")').click();
    
    // Verify post has been deleted
    cy.get('.ant-table-row').should('not.contain', 'Modified E2E Test Post');
  });
});
```

#### 3.3.4 Testing Best Practices

- **Test core user flows**: Test the most commonly used core flows by users
- **Use real data**: Use real test data, avoid using hard-coded test data
- **Keep tests independent**: Each test should be independent and not depend on the results of other tests
- **Use page object pattern**: Encapsulate page operations as page objects to improve test maintainability
- **Set reasonable timeout**: Set reasonable timeout based on network conditions and application performance

## 4. Testing Best Practices

### 4.1 Testing Design Principles

- **AAA principle**: Arrange, Act, Assert
- **Single responsibility principle**: Each test should test only one functional point
- **DRY principle**: Don't Repeat Yourself, avoid duplicate test code
- **FIRST principle**:
  - Fast: Tests should execute quickly
  - Independent: Tests should be independent of each other
  - Repeatable: Test results should be repeatable
  - Self-validating: Tests should automatically validate results
  - Timely: Tests should be written in a timely manner

### 4.2 Test Coverage

- **Target coverage**: Test coverage for core functionality should reach above 80%
- **Coverage metrics**:
  - Line coverage: The percentage of code lines executed by tests out of total code lines
  - Branch coverage: The percentage of branches executed by tests out of total branches
  - Function coverage: The percentage of functions executed by tests out of total functions
  - Statement coverage: The percentage of statements executed by tests out of total statements

### 4.3 Test Execution

- **Local execution**: Developers execute tests during local development
- **CI execution**: Tests are automatically executed during continuous integration
- **Scheduled execution**: Complete test suites are executed regularly
- **On-demand execution**: Specific test cases are executed as needed

### 4.4 Test Reports

- **Generate test reports**: Use tools to generate visual test reports
- **Analyze test results**: Regularly analyze test results to identify issues and improvement points
- **Share test reports**: Share test reports with team members
- **Continuous improvement**: Continuously improve test strategies and code quality based on test reports

## 5. Continuous Integration

Tagtag project uses GitHub Actions for continuous integration to automatically execute tests.

### 5.1 CI Process

1. **Code submission**: Developers submit code to GitHub
2. **Trigger CI**: GitHub Actions automatically triggers the CI process
3. **Install dependencies**: Install project dependencies
4. **Run tests**: Execute unit tests, integration tests, and API tests
5. **Generate reports**: Generate test coverage reports
6. **Deploy application**: If tests pass, deploy the application to the test environment

### 5.2 CI Configuration Example

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package --file pom.xml
    
    - name: Run tests
      run: mvn test
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: tagtag-*/target/surefire-reports/
```

## 6. Summary

Testing is an important means to ensure software quality. Tagtag project adopts a multi-layered testing strategy, including unit testing, integration testing, and API testing. By following testing best practices and using appropriate testing tools, we can improve code quality, reduce regression issues, support continuous integration, and ensure the long-term stable development of the project.

We hope this document can help developers understand the testing methods and best practices of the Tagtag project, write high-quality test cases, and jointly maintain a high-quality codebase.