---
title: Frontend Development Guide
description: Tagtag frontend development guide, including component development specifications, Hooks usage guidelines, and best practices.
---

Tagtag frontend is developed based on Vue 3 + TypeScript + Vite, adopting component-based and modular design concepts. This document will detail the specifications, best practices, and common tools for frontend development.

## 1. Technology Stack

| Technology | Version | Usage |
|------------|---------|-------|
| Vue | 3.3+ | Frontend framework |
| TypeScript | 5.0+ | Type system |
| Vite | 4.3+ | Build tool |
| Pinia | 2.0+ | State management |
| Vue Router | 4.2+ | Routing management |
| Ant Design Vue | 4.0+ | UI component library |
| Axios | 1.5+ | HTTP client |
| ESLint | 8.40+ | Code checking |
| Prettier | 2.8+ | Code formatting |

## 2. Project Structure

The frontend project adopts a Monorepo structure, located in the `tagtag-ui` directory.

```
tagtag-ui/
├── apps/                  # Application directory
│   └── tagtag/            # Main application
│       ├── src/           # Source code
│       │   ├── api/       # API definitions
│       │   ├── assets/    # Static assets
│       │   ├── components/# Public components
│       │   ├── composables/# Composable functions
│       │   ├── hooks/     # Custom Hooks
│       │   ├── layouts/   # Layout components
│       │   ├── locales/   # Internationalization
│       │   ├── router/    # Routing configuration
│       │   ├── store/     # State management
│       │   ├── styles/    # Style files
│       │   ├── types/     # Type definitions
│       │   ├── utils/     # Utility functions
│       │   ├── views/     # Page components
│       │   ├── app.vue    # Root component
│       │   └── main.ts    # Entry file
│       ├── public/        # Public resources
│       ├── index.html     # HTML template
│       ├── vite.config.ts # Vite configuration
│       └── tsconfig.json  # TypeScript configuration
├── packages/              # Public packages
│   ├── components/        # Public component library
│   └── utils/             # Public utility library
└── pnpm-workspace.yaml    # pnpm workspace configuration
```

## 3. Component Development Specifications

### 3.1 Component Naming

- **File name**: Use PascalCase, e.g., `FormModal.vue`
- **Component name**: Consistent with file name, use PascalCase
- **Component tag**: Use kebab-case in templates, e.g., `<form-modal></form-modal>`

### 3.2 Component Structure

Components should follow the structure below:

```vue
<template>
  <!-- Component template -->
</template>

<script setup lang="ts">
// Component logic
</script>

<style scoped>
/* Component styles */
</style>
```

### 3.3 Component Logic Organization

- Use `script setup` syntax sugar to simplify component development
- Organize code in the following order:
  1. Import statements
  2. Component Props definition
  3. Emits definition
  4. Reactive data definition
  5. Computed properties
  6. Lifecycle hooks
  7. Method definitions
  8. Event handling

**Example**:

```vue
<template>
  <div class="form-modal">
    <a-modal
      v-model:open="visible"
      :title="title"
      @ok="handleOk"
      @cancel="handleCancel"
    >
      <a-form :model="formData" :rules="rules" ref="formRef">
        <!-- Form content -->
      </a-form>
    </a-modal>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, onMounted } from 'vue';
import { FormInstance } from 'ant-design-vue';

// Props definition
const props = defineProps<{
  visible: boolean;
  title?: string;
  initialData?: any;
}>();

// Emits definition
const emit = defineEmits<{
  (e: 'update:visible', value: boolean): void;
  (e: 'submit', data: any): void;
}>();

// Reactive data
const formRef = ref<FormInstance | null>(null);
const formData = reactive<any>({
  // Form fields
});

// Computed properties
const rules = computed(() => ({
  // Form rules
}));

// Lifecycle hooks
onMounted(() => {
  if (props.initialData) {
    Object.assign(formData, props.initialData);
  }
});

// Methods
const handleOk = async () => {
  if (formRef.value) {
    await formRef.value.validate();
    emit('submit', formData);
    emit('update:visible', false);
  }
};

const handleCancel = () => {
  emit('update:visible', false);
};
</script>

<style scoped>
.form-modal {
  /* Component styles */
}
</style>
```

### 3.4 Component Communication

- **Props/Emits**: Preferred for parent-child component communication
- **Provide/Inject**: Pass data from ancestor to descendant components
- **Pinia**: Global state management
- **Event Bus**: Not recommended, use Pinia instead

### 3.5 Component Styles

- Use `scoped` attribute to ensure style scope isolation
- Adopt BEM naming convention: `block__element--modifier`
- Avoid using `!important`
- Use CSS variables to manage theme colors and general styles

**Example**:

```css
/* BEM naming convention */
.post-card {
  /* Block styles */
}

.post-card__title {
  /* Element styles */
}

.post-card--highlight {
  /* Modifier styles */
}
```

## 4. Hooks Usage Guidelines

### 4.1 Custom Hooks Naming

- Use `use` prefix, e.g., `useAuth`, `useTable`
- File name should be consistent with Hook name, use camelCase

### 4.2 Common Built-in Hooks

| Hook | Usage |
|-----|-----|
| `ref` | Create reactive data |
| `reactive` | Create reactive object |
| `computed` | Create computed property |
| `watch` | Listen for data changes |
| `watchEffect` | Automatically listen for dependency changes |
| `onMounted` | Execute after component is mounted |
| `onUpdated` | Execute after component is updated |
| `onUnmounted` | Execute before component is unmounted |
| `provide` | Provide data to descendant components |
| `inject` | Get data from ancestor components |

### 4.3 Custom Hooks Examples

#### 4.3.1 `useAuth` Hook

Used to manage user authentication status.

```typescript
// src/hooks/useAuth.ts
import { useAuthStore } from '@/store/auth';
import { computed } from 'vue';

export function useAuth() {
  const authStore = useAuthStore();

  const isAuthenticated = computed(() => !!authStore.token);
  const userInfo = computed(() => authStore.userInfo);
  const permissions = computed(() => authStore.permissions);

  const hasPermission = (permission: string) => {
    return permissions.value.includes(permission);
  };

  const login = async (loginData: any) => {
    return authStore.login(loginData);
  };

  const logout = async () => {
    return authStore.logout();
  };

  return {
    isAuthenticated,
    userInfo,
    permissions,
    hasPermission,
    login,
    logout
  };
}
```

#### 4.3.2 `useTable` Hook

Used to simplify table component development.

```typescript
// src/hooks/useTable.ts
import { ref, reactive, computed } from 'vue';

export function useTable<T>(fetchData: (params: any) => Promise<any>) {
  const loading = ref(false);
  const dataSource = ref<T[]>([]);
  const total = ref(0);
  
  const pagination = reactive({
    current: 1,
    pageSize: 10,
    showSizeChanger: true,
    pageSizeOptions: ['10', '20', '50', '100'],
    showTotal: (total: number) => `Total ${total} records`
  });
  
  const searchParams = reactive<any>({});
  
  const fetchTableData = async () => {
    loading.value = true;
    try {
      const params = {
        page: pagination.current,
        size: pagination.pageSize,
        ...searchParams
      };
      const result = await fetchData(params);
      dataSource.value = result.records || [];
      total.value = result.total || 0;
    } catch (error) {
      console.error('Failed to fetch table data:', error);
    } finally {
      loading.value = false;
    }
  };
  
  const handleSearch = () => {
    pagination.current = 1;
    fetchTableData();
  };
  
  const handleReset = () => {
    // Reset search parameters
    Object.keys(searchParams).forEach(key => {
      searchParams[key] = '';
    });
    pagination.current = 1;
    fetchTableData();
  };
  
  const handlePageChange = (page: number, pageSize: number) => {
    pagination.current = page;
    pagination.pageSize = pageSize;
    fetchTableData();
  };
  
  return {
    loading,
    dataSource,
    total,
    pagination,
    searchParams,
    fetchTableData,
    handleSearch,
    handleReset,
    handlePageChange
  };
}
```

### 4.4 Hooks Best Practices

- **Single Responsibility**: Each Hook is responsible for only one function
- **Reusability**: Design general Hooks, avoid business logic coupling
- **Type Safety**: Add complete TypeScript type definitions for Hooks
- **Clean Up Side Effects**: Clean up side effects when components are unmounted, such as timers, event listeners, etc.

## 5. State Management

### 5.1 Pinia Specifications

- **Store Naming**: Use PascalCase, e.g., `AuthStore`
- **File Structure**: Each module corresponds to a Store file
- **State Definition**: Use `state` function to define reactive state
- **Action Naming**: Use camelCase, async Actions should return Promise
- **Getters Naming**: Use camelCase

**Example**:

```typescript
// src/store/auth.ts
import { defineStore } from 'pinia';
import { loginApi, logoutApi } from '@/api/core/auth';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]')
  }),
  
  getters: {
    isAuthenticated: (state) => !!state.token,
    hasPermission: (state) => (permission: string) => {
      return state.permissions.includes(permission);
    }
  },
  
  actions: {
    async login(loginData: any) {
      const result = await loginApi(loginData);
      this.token = result.token;
      this.userInfo = result.user;
      this.permissions = result.user.permissions || [];
      
      localStorage.setItem('token', this.token);
      localStorage.setItem('userInfo', JSON.stringify(this.userInfo));
      localStorage.setItem('permissions', JSON.stringify(this.permissions));
      
      return result;
    },
    
    async logout() {
      await logoutApi();
      this.clearAuth();
    },
    
    clearAuth() {
      this.token = '';
      this.userInfo = null;
      this.permissions = [];
      
      localStorage.removeItem('token');
      localStorage.removeItem('userInfo');
      localStorage.removeItem('permissions');
    }
  }
});
```

### 5.2 State Management Best Practices

- **Reasonable Store Division**: Divide Store by functional modules, avoid single Store being too large
- **Avoid Overusing Global State**: Only put globally shared state into Store
- **Use Actions for Async Logic**: All async operations should be placed in Actions
- **Persistent Storage**: For states that need persistence, use localStorage or cookie storage

## 6. API Requests

### 6.1 Axios Configuration

The frontend uses Axios for API requests, and the configuration is located in `src/api/index.ts`.

**Example**:

```typescript
// src/api/index.ts
import axios from 'axios';
import { useAuthStore } from '@/store/auth';

const request = axios.create({
  baseURL: import.meta.env.VITE_APP_API_BASE_URL,
  timeout: 10000
});

// Request interceptor
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor
request.interceptors.response.use(
  (response) => {
    return response.data;
  },
  async (error) => {
    // Error handling logic
    return Promise.reject(error);
  }
);

export default request;
```

### 6.2 API Modularization

Divide APIs by modules, each module corresponds to a file.

**Example**:

```typescript
// src/api/modules/user.ts
import request from '../index';

export const userApi = {
  // Get user list
  getList: (params: any) => {
    return request.get('/users', { params });
  },
  
  // Get user detail
  getDetail: (id: number) => {
    return request.get(`/users/${id}`);
  },
  
  // Create user
  create: (data: any) => {
    return request.post('/users', data);
  },
  
  // Update user
  update: (data: any) => {
    return request.put('/users', data);
  },
  
  // Delete user
  delete: (id: number) => {
    return request.delete(`/users/${id}`);
  }
};
```

### 6.3 API Calling Specifications

- **Use async/await**: Uniformly use async/await to handle async requests
- **Error Handling**: Add try/catch to handle errors when calling APIs
- **Parameter Validation**: Validate parameter legitimacy before calling APIs
- **Loading State**: Display appropriate loading state to improve user experience

## 7. Routing Management

### 7.1 Routing Configuration

Routing configuration is located in the `src/router` directory, adopting a modular design.

**Example**:

```typescript
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router';
import Layout from '@/layouts/main.vue';

const routes = [
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: {
          title: 'Dashboard',
          icon: 'dashboard',
          permission: 'sys:dashboard:view'
        }
      }
    ]
  },
  {
    path: '/auth',
    component: () => import('@/layouts/auth.vue'),
    children: [
      {
        path: 'login',
        name: 'Login',
        component: () => import('@/views/auth/login.vue'),
        meta: {
          title: 'Login',
          requiresAuth: false
        }
      }
    ]
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/error/404.vue')
  }
];

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
});

export default router;
```

### 7.2 Route Guards

Use route guards to implement permission control and page jump logic.

**Example**:

```typescript
// src/router/guard.ts
import router from './index';
import { useAuthStore } from '@/store/auth';

router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore();
  
  // Set page title
  document.title = `${to.meta.title || 'Tagtag'} - Admin System`;
  
  // Check if authentication is required
  if (to.meta.requiresAuth !== false) {
    if (authStore.isAuthenticated) {
      // Logged in, check permission
      if (to.meta.permission) {
        if (authStore.hasPermission(to.meta.permission as string)) {
          next();
        } else {
          // No permission, redirect to 403 page
          next({ path: '/403' });
        }
      } else {
        next();
      }
    } else {
      // Not logged in, redirect to login page
      next({ path: '/auth/login', query: { redirect: to.fullPath } });
    }
  } else {
    next();
  }
});
```

## 8. Code Specifications

### 8.1 ESLint Rules

The frontend project uses ESLint for code checking, and the rules are configured in the `.eslintrc.cjs` file.

Main rules:
- Indentation: Use 2 spaces
- Quotes: Use single quotes
- Semicolons: Do not use semicolons
- Trailing Commas: Use trailing commas
- Forbid unused variables
- Forbid unused imports

### 8.2 Prettier Configuration

Use Prettier for code formatting, and the configuration is located in the `.prettierrc` file.

### 8.3 Commit Specifications

Use Commitizen to commit code, following the Angular commit specification:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types**:
- `feat`: New feature
- `fix`: Fix bug
- `docs`: Documentation update
- `style`: Code style update
- `refactor`: Code refactoring
- `test`: Test update
- `chore`: Build tool or dependency update

## 9. Testing

### 9.1 Unit Testing

Use Vitest for unit testing, and test files are located in the `__tests__` directory.

**Example**:

```typescript
// src/components/Button/__tests__/Button.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Button from '../Button.vue';

describe('Button Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Button Text'
      }
    });
    expect(wrapper.text()).toBe('Button Text');
  });
  
  it('should emit click event', () => {
    const wrapper = mount(Button);
    wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeTruthy();
  });
});
```

### 9.2 E2E Testing

Use Cypress for end-to-end testing, and test files are located in the `cypress/e2e` directory.

## 10. Performance Optimization

### 10.1 Component Optimization

- **Lazy Load Components**: Use `defineAsyncComponent` or dynamic import to lazy load components
- **Use `v-once`**: Use `v-once` directive for static content
- **Use `v-memo`**: Use `v-memo` directive for frequently updated lists
- **Avoid Unnecessary Rendering**: Use `computed` and `watch` to optimize rendering logic

### 10.2 Network Optimization

- **HTTP Cache**: Set reasonable cache policies
- **Compress Resources**: Enable Gzip or Brotli compression
- **CDN Acceleration**: Use CDN to accelerate static resource access
- **Reduce Request Times**: Merge requests, use HTTP/2

### 10.3 Build Optimization

- **Code Splitting**: Use Vite's code splitting feature
- **Tree Shaking**: Remove unused code
- **On-Demand Loading**: Load third-party libraries on demand
- **Prebuild Dependencies**: Use Vite's dependency prebuild feature

## 11. Development Tools

### 11.1 VS Code Plugins

- **Volar**: Vue 3 official extension
- **TypeScript Vue Plugin**: TypeScript Vue support
- **ESLint**: Code checking
- **Prettier**: Code formatting
- **GitLens**: Git enhancement
- **Ant Design Vue Helper**: Ant Design Vue component assistance

### 11.2 Command Line Tools

```bash
# Install dependencies
pnpm install

# Start development server
pnpm dev

# Build production version
pnpm build

# Preview production version
pnpm preview

# Run ESLint
pnpm lint

# Run Prettier
pnpm format

# Run unit tests
pnpm test:unit

# Run E2E tests
pnpm test:e2e
```

## 12. Best Practices

### 12.1 Code Readability

- **Comments**: Add comments for complex logic
- **Naming Conventions**: Use meaningful variable and function names
- **Code Structure**: Organize code structure reasonably, use blank lines to separate different logic blocks
- **Indentation**: Maintain consistent indentation style

### 12.2 Maintainability

- **Modular Design**: Split code into reusable modules
- **Documentation**: Write documentation for public components and functions
- **Testing**: Write test cases for core functionality
- **Version Control**: Use Git reasonably, moderate commit granularity

### 12.3 User Experience

- **Responsive Design**: Adapt to different screen sizes
- **Loading State**: Display appropriate loading state
- **Error Handling**: Friendly error prompts
- **Animation Effects**: Appropriate animation effects to improve user experience
- **Performance Optimization**: Ensure smooth page loading and interaction

## 13. Summary

This document introduces the specifications, best practices, and common tools for Tagtag frontend development. Following these specifications can improve code quality, maintainability, and development efficiency, ensuring smooth team collaboration.

Frontend development is a continuously evolving field. Developers are advised to keep up with the latest developments in Vue 3, TypeScript, and other technologies, and continuously learn and practice new technologies and best practices.