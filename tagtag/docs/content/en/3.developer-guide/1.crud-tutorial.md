---
title: 'Practical Tutorial: Developing CRUD Features'
description: Develop a complete CRUD functional module from scratch.
---

# Practical Tutorial: Developing CRUD Features

This tutorial will guide you through the complete process of developing a simple **"Post Management"** module using Tagtag, covering both backend and frontend implementation.

We will implement the following features:
1.  Paginated query for posts.
2.  Create a new post.
3.  Edit an existing post.
4.  Delete a post.

---

## Step 1: Backend Development

### 1. Database Design

First, create the `sys_post` table in your database.

```sql
CREATE TABLE `sys_post` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'Primary Key',
  `title` varchar(100) NOT NULL COMMENT 'Post Title',
  `content` text COMMENT 'Post Content',
  `status` tinyint(4) DEFAULT 1 COMMENT 'Status: 1-Published, 0-Draft',
  `create_time` datetime DEFAULT NULL COMMENT 'Create Time',
  `update_time` datetime DEFAULT NULL COMMENT 'Update Time',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Post Table';
```

### 2. Define Contract

Define DTOs (Data Transfer Objects) in the `tagtag-contract` module. Create `PostDTO.java` and `PostQuery.java`.

**PostDTO.java (For Create/Update)**
```java
package dev.tagtag.contract.system.dto;

import lombok.Data;
import jakarta.validation.constraints.NotBlank;

@Data
public class PostDTO {
    private Long id;

    @NotBlank(message = "Title cannot be empty")
    private String title;

    private String content;

    private Integer status;
}
```

**PostQuery.java (For Query)**
```java
package dev.tagtag.contract.system.query;

import dev.tagtag.common.model.PageQuery; // Inherits base pagination fields
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class PostQuery extends PageQuery {
    private String title;
    private Integer status;
}
```

### 3. Persistence Layer (Mapper & Entity)

Create the Entity and Mapper in the `tagtag-module-system` module.

**PostEntity.java**
```java
package dev.tagtag.module.system.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import dev.tagtag.framework.mybatis.entity.BaseEntity; // Includes id, createTime, updateTime
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_post")
public class PostEntity extends BaseEntity {
    private String title;
    private String content;
    private Integer status;
}
```

**PostMapper.java**
```java
package dev.tagtag.module.system.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import dev.tagtag.module.system.entity.PostEntity;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface PostMapper extends BaseMapper<PostEntity> {
}
```

### 4. Service Layer

**PostService.java**
```java
public interface PostService {
    PageResult<PostEntity> page(PostQuery query);
    void save(PostDTO dto);
    void update(PostDTO dto);
    void delete(List<Long> ids);
}
```

**PostServiceImpl.java**
```java
@Service
@RequiredArgsConstructor
public class PostServiceImpl implements PostService {
    private final PostMapper postMapper;

    @Override
    public PageResult<PostEntity> page(PostQuery query) {
        // Use MyBatis Plus pagination interceptor
        Page<PostEntity> page = new Page<>(query.getPage(), query.getSize());
        LambdaQueryWrapper<PostEntity> wrapper = new LambdaQueryWrapper<PostEntity>()
                .like(StringUtils.isNotBlank(query.getTitle()), PostEntity::getTitle, query.getTitle())
                .eq(query.getStatus() != null, PostEntity::getStatus, query.getStatus())
                .orderByDesc(PostEntity::getCreateTime);
        
        return PageResult.of(postMapper.selectPage(page, wrapper));
    }

    @Override
    public void save(PostDTO dto) {
        PostEntity entity = BeanUtil.copyProperties(dto, PostEntity.class);
        postMapper.insert(entity);
    }

    // Implement update and delete similarly...
}
```

### 5. Controller Layer

```java
@RestController
@RequestMapping("/posts")
@Tag(name = "Post Management")
public class PostController {
    
    @Resource
    private PostService postService;

    @GetMapping
    @Operation(summary = "Paginated Query")
    @PreAuthorize("@ss.hasPermission('sys:post:query')")
    public Result<PageResult<PostEntity>> page(PostQuery query) {
        return Result.success(postService.page(query));
    }

    @PostMapping
    @Operation(summary = "Create Post")
    @OperationLog(module = "Post Management", name = "Create Post", type = OperationType.ADD)
    @PreAuthorize("@ss.hasPermission('sys:post:add')")
    public Result<Void> save(@RequestBody @Valid PostDTO dto) {
        postService.save(dto);
        return Result.success();
    }
    
    // Other methods...
}
```

---

## Step 2: Frontend Development

### 1. Define API

Define the request methods in `tagtag-ui/apps/tagtag/src/api/modules/system/post.ts`.

```typescript
import { request } from '@/api/request';

export function getPostPage(params: any) {
  return request.get({ url: '/posts', params });
}

export function addPost(data: any) {
  return request.post({ url: '/posts', data });
}

export function updatePost(data: any) {
  return request.put({ url: '/posts', data });
}

export function deletePost(ids: number[]) {
  return request.delete({ url: '/posts', data: ids });
}
```

### 2. Create List Page

Create `tagtag-ui/apps/tagtag/src/views/modules/system/post/index.vue`.

```vue
<script setup lang="ts">
import { useTable } from '@vben/plugins/vxe-table';
import { getPostPage, deletePost } from '@/api/modules/system/post';

const [Grid, gridApi] = useTable({
  api: getPostPage,
  columns: [
    { type: 'checkbox', width: 50 },
    { field: 'title', title: 'Title' },
    { field: 'status', title: 'Status', slots: { default: 'status' } },
    { field: 'createTime', title: 'Create Time' },
    { title: 'Action', slots: { default: 'action' }, width: 150 },
  ],
  formConfig: {
    items: [
      { field: 'title', label: 'Title', component: 'Input' }
    ]
  },
  toolbarConfig: {
    buttons: [
      { code: 'add', name: 'Add', status: 'primary' },
      { code: 'delete', name: 'Delete', status: 'danger' }
    ]
  }
});

function handleAdd() {
  // Logic to open modal...
}
</script>

<template>
  <Grid>
    <template #status="{ row }">
      <Tag :color="row.status === 1 ? 'green' : 'red'">
        {{ row.status === 1 ? 'Published' : 'Draft' }}
      </Tag>
    </template>
    <template #action="{ row }">
      <Button type="link" @click="handleEdit(row)">Edit</Button>
      <Button type="link" danger @click="handleDelete(row)">Delete</Button>
    </template>
  </Grid>
</template>
```

### 3. Configure Menu

1.  Start the project and log in as an administrator.
2.  Navigate to **System Management -> Menu Management**.
3.  Add a new menu named "Post Management", set the route to `/system/post`, and the component path to `modules/system/post/index.vue`.
4.  Refresh the page to see the new feature.

---

## Summary

Congratulations! You have successfully developed a complete CRUD module with full frontend and backend interaction. Tagtag's modular design makes this process clear and standardized.
