---
title: 'Practical Tutorial: Developing CRUD Features'
description: Develop a complete CRUD functional module from scratch.
---

This tutorial will guide you through the complete process of developing a simple **"Post Management"** module using Tagtag, covering both backend and frontend implementation.

We will implement the following features:
1.  Paginated query for posts.
2.  Create a new post.
3.  Edit an existing post.
4.  Delete a post.

---

## Step 1: Backend Development

### 1. Database Design

First, create the `sys_post` table in your database.

```sql
CREATE TABLE `sys_post` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'Primary Key',
  `title` varchar(100) NOT NULL COMMENT 'Post Title',
  `content` text COMMENT 'Post Content',
  `status` tinyint(4) DEFAULT 1 COMMENT 'Status: 1-Published, 0-Draft',
  `create_time` datetime DEFAULT NULL COMMENT 'Create Time',
  `update_time` datetime DEFAULT NULL COMMENT 'Update Time',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='Post Table';
```

### 2. Define Contract

Define DTOs (Data Transfer Objects) in the `tagtag-contract` module. Create `PostDTO.java` and `PostQuery.java`.

**PostDTO.java (For Create/Update)**
```java
package dev.tagtag.contract.system.dto;

import lombok.Data;
import jakarta.validation.constraints.NotBlank;

@Data
public class PostDTO {
    private Long id;

    @NotBlank(message = "Title cannot be empty")
    private String title;

    private String content;

    private Integer status;
}
```

**PostQuery.java (For Query)**
```java
package dev.tagtag.contract.system.query;

import dev.tagtag.common.model.PageQuery; // Inherits base pagination fields
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
public class PostQuery extends PageQuery {
    private String title;
    private Integer status;
}
```

### 3. Persistence Layer (Mapper & Entity)

Create the Entity and Mapper in the `tagtag-module-system` module.

**PostEntity.java**
```java
package dev.tagtag.module.system.entity;

import com.baomidou.mybatisplus.annotation.TableName;
import dev.tagtag.framework.mybatis.entity.BaseEntity; // Includes id, createTime, updateTime
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_post")
public class PostEntity extends BaseEntity {
    private String title;
    private String content;
    private Integer status;
}
```

**PostMapper.java**
```java
package dev.tagtag.module.system.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import dev.tagtag.module.system.entity.PostEntity;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface PostMapper extends BaseMapper<PostEntity> {
}
```

### 4. Service Layer

**PostService.java**
```java
public interface PostService {
    PageResult<PostEntity> page(PostQuery query);
    void save(PostDTO dto);
    void update(PostDTO dto);
    void delete(List<Long> ids);
}
```

**PostServiceImpl.java**
```java
@Service
@RequiredArgsConstructor
public class PostServiceImpl implements PostService {
    private final PostMapper postMapper;

    @Override
    public PageResult<PostEntity> page(PostQuery query) {
        // Use MyBatis Plus pagination interceptor
        Page<PostEntity> page = new Page<>(query.getPage(), query.getSize());
        LambdaQueryWrapper<PostEntity> wrapper = new LambdaQueryWrapper<PostEntity>()
                .like(StringUtils.isNotBlank(query.getTitle()), PostEntity::getTitle, query.getTitle())
                .eq(query.getStatus() != null, PostEntity::getStatus, query.getStatus())
                .orderByDesc(PostEntity::getCreateTime);
        
        return PageResult.of(postMapper.selectPage(page, wrapper));
    }

    @Override
    public void save(PostDTO dto) {
        PostEntity entity = BeanUtil.copyProperties(dto, PostEntity.class);
        postMapper.insert(entity);
    }

    @Override
    public void update(PostDTO dto) {
        PostEntity entity = BeanUtil.copyProperties(dto, PostEntity.class);
        postMapper.updateById(entity);
    }

    @Override
    public void delete(List<Long> ids) {
        postMapper.deleteBatchIds(ids);
    }
}
```

### 5. Controller Layer

```java
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/posts")
@Tag(name = "Post Management")
@RequiredArgsConstructor
public class PostController {
    
    private final PostService postService;

    @GetMapping
    @Operation(summary = "Paginated Query")
    @PreAuthorize("@ss.hasPermission('sys:post:query')")
    public Result<PageResult<PostEntity>> page(PostQuery query) {
        return Result.success(postService.page(query));
    }

    @PostMapping
    @Operation(summary = "Create Post")
    @OperationLog(module = "Post Management", name = "Create Post", type = OperationType.ADD)
    @PreAuthorize("@ss.hasPermission('sys:post:add')")
    public Result<Void> save(@RequestBody @Validated PostDTO dto) {
        postService.save(dto);
        return Result.success();
    }

    @PutMapping
    @Operation(summary = "Update Post")
    @OperationLog(module = "Post Management", name = "Update Post", type = OperationType.UPDATE)
    @PreAuthorize("@ss.hasPermission('sys:post:update')")
    public Result<Void> update(@RequestBody @Validated PostDTO dto) {
        postService.update(dto);
        return Result.success();
    }

    @DeleteMapping
    @Operation(summary = "Delete Post")
    @OperationLog(module = "Post Management", name = "Delete Post", type = OperationType.DELETE)
    @PreAuthorize("@ss.hasPermission('sys:post:delete')")
    public Result<Void> delete(@RequestBody List<Long> ids) {
        postService.delete(ids);
        return Result.success();
    }
}
```

---

## Step 2: Frontend Development

### 1. Define API

Define the request methods in `tagtag-ui/apps/tagtag/src/api/modules/system/post.ts`.

```typescript
import { request } from '@/api/request';

export function getPostPage(params: any) {
  return request.get({ url: '/posts', params });
}

export function addPost(data: any) {
  return request.post({ url: '/posts', data });
}

export function updatePost(data: any) {
  return request.put({ url: '/posts', data });
}

export function deletePost(ids: number[]) {
  return request.delete({ url: '/posts', data: ids });
}
```

### 2. Create List Page

Create `tagtag-ui/apps/tagtag/src/views/modules/system/post/index.vue`.

```vue
<script setup lang="ts">
import { ref, reactive } from 'vue';
import { useTable } from '@vben/plugins/vxe-table';
import { getPostPage, deletePost, addPost, updatePost } from '@/api/modules/system/post';
import { Button, Tag, Modal } from 'ant-design-vue';
import FormModal from './FormModal.vue';

// Table configuration
const [Grid, gridApi] = useTable({
  api: getPostPage,
  columns: [
    { type: 'checkbox', width: 50 },
    { field: 'title', title: 'Title' },
    { field: 'status', title: 'Status', slots: { default: 'status' } },
    { field: 'createTime', title: 'Create Time', width: 180 },
    { title: 'Action', slots: { default: 'action' }, width: 150 },
  ],
  formConfig: {
    items: [
      { field: 'title', label: 'Title', component: 'Input' },
      { 
        field: 'status', 
        label: 'Status', 
        component: 'Select',
        componentProps: {
          options: [
            { label: 'Published', value: 1 },
            { label: 'Draft', value: 0 }
          ]
        }
      }
    ]
  },
  toolbarConfig: {
    buttons: [
      { code: 'add', name: 'Add', status: 'primary' },
      { code: 'delete', name: 'Delete', status: 'danger' }
    ]
  }
});

// Modal configuration
const modalVisible = ref(false);
const modalTitle = ref('');
const formData = reactive({});
const isEdit = ref(false);

// Open add modal
function handleAdd() {
  isEdit.value = false;
  modalTitle.value = 'Add Post';
  Object.assign(formData, {});
  modalVisible.value = true;
}

// Open edit modal
function handleEdit(row) {
  isEdit.value = true;
  modalTitle.value = 'Edit Post';
  Object.assign(formData, row);
  modalVisible.value = true;
}

// Delete single post
async function handleDelete(row) {
  Modal.confirm({
    title: 'Confirm Delete',
    content: `Are you sure you want to delete the post "${row.title}"?`,
    onOk: async () => {
      await deletePost([row.id]);
      gridApi.refresh();
    }
  });
}

// Batch delete
async function handleBatchDelete(ids) {
  Modal.confirm({
    title: 'Confirm Delete',
    content: `Are you sure you want to delete the selected ${ids.length} posts?`,
    onOk: async () => {
      await deletePost(ids);
      gridApi.refresh();
    }
  });
}

// Save post
async function handleSave(data) {
  if (isEdit.value) {
    await updatePost(data);
  } else {
    await addPost(data);
  }
  modalVisible.value = false;
  gridApi.refresh();
}

// Listen for toolbar button clicks
function handleToolbarClick(button) {
  if (button.code === 'add') {
    handleAdd();
  } else if (button.code === 'delete') {
    const selectedRows = gridApi.getSelectedRows();
    if (selectedRows.length === 0) {
      Modal.warning({ title: 'Tip', content: 'Please select posts to delete' });
      return;
    }
    handleBatchDelete(selectedRows.map(row => row.id));
  }
}
</script>

<template>
  <Grid @toolbar-click="handleToolbarClick">
    <template #status="{ row }">
      <Tag :color="row.status === 1 ? 'green' : 'red'">
        {{ row.status === 1 ? 'Published' : 'Draft' }}
      </Tag>
    </template>
    <template #action="{ row }">
      <Button type="link" @click="handleEdit(row)">Edit</Button>
      <Button type="link" danger @click="handleDelete(row)">Delete</Button>
    </template>
  </Grid>

  <!-- Add/Edit Modal -->
  <FormModal
    v-model:visible="modalVisible"
    :title="modalTitle"
    :form-data="formData"
    @save="handleSave"
  />
</template>
```

### 3. Create Form Modal Component

Create `tagtag-ui/apps/tagtag/src/views/modules/system/post/FormModal.vue`.

```vue
<script setup lang="ts">
import { ref, reactive, watch } from 'vue';
import { Modal, Form, Input, Select, Switch } from 'ant-design-vue';

// Props
const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  title: {
    type: String,
    default: ''
  },
  formData: {
    type: Object,
    default: () => ({})
  }
});

// Emits
const emit = defineEmits(['update:visible', 'save']);

// Form instance
const formRef = ref();

// Form model
const formModel = reactive({
  id: null,
  title: '',
  content: '',
  status: 1
});

// Watch form data changes
watch(
  () => props.formData,
  (newData) => {
    Object.assign(formModel, newData);
  },
  { deep: true, immediate: true }
);

// Close modal
function handleCancel() {
  emit('update:visible', false);
  formRef.value?.resetFields();
}

// Submit form
async function handleSubmit() {
  if (!formRef.value) return;
  
  try {
    await formRef.value.validate();
    emit('save', { ...formModel });
    emit('update:visible', false);
  } catch (error) {
    console.error('Form validation failed:', error);
  }
}
</script>

<template>
  <Modal
    v-model:open="visible"
    :title="title"
    ok-text="Save"
    cancel-text="Cancel"
    @ok="handleSubmit"
    @cancel="handleCancel"
    width="800px"
  >
    <Form
      ref="formRef"
      :model="formModel"
      layout="vertical"
      :rules="{
        title: [{ required: true, message: 'Please enter post title', trigger: 'blur' }],
        content: [{ required: true, message: 'Please enter post content', trigger: 'blur' }]
      }"
    >
      <Form.Item name="id" hidden>
        <Input v-model:value="formModel.id" />
      </Form.Item>
      
      <Form.Item label="Post Title" name="title">
        <Input v-model:value="formModel.title" placeholder="Please enter post title" />
      </Form.Item>
      
      <Form.Item label="Post Content" name="content">
        <Input.TextArea 
          v-model:value="formModel.content" 
          placeholder="Please enter post content"
          rows="6"
        />
      </Form.Item>
      
      <Form.Item label="Publish Status" name="status">
        <Switch 
          v-model:checked="formModel.status" 
          checked-children="Published" 
          un-checked-children="Draft"
        />
      </Form.Item>
    </Form>
  </Modal>
</template>
```

### 4. Configure Menu

1.  Start the project and log in as an administrator.
2.  Navigate to **System Management -> Menu Management**.
3.  Add a new menu named "Post Management", set the route to `/system/post`, and the component path to `modules/system/post/index.vue`.
4.  Refresh the page to see the new feature.

---

## Step 3: Test Case Writing

### 1. Backend Unit Test

To ensure code quality and functional correctness, we need to write unit tests for the backend service. Tagtag uses JUnit 5 and Mockito for unit testing.

#### 1.1 Prepare Test Environment

First, ensure the necessary test dependencies are added to `pom.xml`:

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>
```

#### 1.2 Write Service Layer Tests

Create `PostServiceImplTest.java` file in the `src/test/java` directory:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(MockitoExtension.class)
class PostServiceImplTest {

    @Mock
    private PostMapper postMapper;

    @InjectMocks
    private PostServiceImpl postService;

    @Test
    void testPage() {
        // Prepare test data
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("test");

        // Mock pagination result
        Page<PostEntity> page = new Page<>(1, 10);
        List<PostEntity> records = new ArrayList<>();
        records.add(new PostEntity(1L, "Test Post", "Content", 1));
        page.setRecords(records);
        page.setTotal(1);

        // Set Mock behavior
        when(postMapper.selectPage(any(Page.class), any(LambdaQueryWrapper.class))).thenReturn(page);

        // Execute test
        PageResult<PostEntity> result = postService.page(query);

        // Verify result
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("Test Post");
    }

    @Test
    void testSave() {
        // Prepare test data
        PostDTO dto = new PostDTO();
        dto.setTitle("Test Post");
        dto.setContent("Content");
        dto.setStatus(1);

        // Set Mock behavior
        when(postMapper.insert(any(PostEntity.class))).thenReturn(1);

        // Execute test
        postService.save(dto);

        // Verify result (can add more verifications)
        Mockito.verify(postMapper, times(1)).insert(any(PostEntity.class));
    }

    @Test
    void testUpdate() {
        // Prepare test data
        PostDTO dto = new PostDTO();
        dto.setId(1L);
        dto.setTitle("Updated Test Post");
        dto.setContent("Updated Content");
        dto.setStatus(0);

        // Set Mock behavior
        when(postMapper.updateById(any(PostEntity.class))).thenReturn(1);

        // Execute test
        postService.update(dto);

        // Verify result
        Mockito.verify(postMapper, times(1)).updateById(any(PostEntity.class));
    }

    @Test
    void testDelete() {
        // Prepare test data
        List<Long> ids = Arrays.asList(1L, 2L, 3L);

        // Set Mock behavior
        when(postMapper.deleteBatchIds(ids)).thenReturn(3);

        // Execute test
        postService.delete(ids);

        // Verify result
        Mockito.verify(postMapper, times(1)).deleteBatchIds(ids);
    }
}
```

### 2. Frontend Testing

Frontend testing includes unit testing and integration testing. Tagtag uses Vitest for unit testing and Cypress for E2E testing.

#### 2.1 Write API Tests

Create `post.test.ts` file in the `tagtag-ui/apps/tagtag/src/api/modules/system/__tests__` directory:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { getPostPage, addPost, updatePost, deletePost } from '../post';
import { request } from '@/api/request';

// Mock request module
vi.mock('@/api/request', () => ({
  request: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn()
  }
}));

describe('Post API', () => {
  it('getPostPage should call request.get with correct params', async () => {
    // Prepare test data
    const params = { page: 1, size: 10, title: 'test' };
    const mockResponse = { data: { records: [], total: 0 } };
    
    // Set mock return value
    (request.get as vi.Mock).mockResolvedValue(mockResponse);
    
    // Execute test
    const result = await getPostPage(params);
    
    // Verify result
    expect(request.get).toHaveBeenCalledWith({ url: '/posts', params });
    expect(result).toEqual(mockResponse);
  });
  
  it('addPost should call request.post with correct data', async () => {
    // Prepare test data
    const data = { title: 'test', content: 'test content', status: 1 };
    const mockResponse = { data: { success: true } };
    
    // Set mock return value
    (request.post as vi.Mock).mockResolvedValue(mockResponse);
    
    // Execute test
    const result = await addPost(data);
    
    // Verify result
    expect(request.post).toHaveBeenCalledWith({ url: '/posts', data });
    expect(result).toEqual(mockResponse);
  });
  
  it('updatePost should call request.put with correct data', async () => {
    // Prepare test data
    const data = { id: 1, title: 'updated', content: 'updated content', status: 0 };
    const mockResponse = { data: { success: true } };
    
    // Set mock return value
    (request.put as vi.Mock).mockResolvedValue(mockResponse);
    
    // Execute test
    const result = await updatePost(data);
    
    // Verify result
    expect(request.put).toHaveBeenCalledWith({ url: '/posts', data });
    expect(result).toEqual(mockResponse);
  });
  
  it('deletePost should call request.delete with correct ids', async () => {
    // Prepare test data
    const ids = [1, 2, 3];
    const mockResponse = { data: { success: true } };
    
    // Set mock return value
    (request.delete as vi.Mock).mockResolvedValue(mockResponse);
    
    // Execute test
    const result = await deletePost(ids);
    
    // Verify result
    expect(request.delete).toHaveBeenCalledWith({ url: '/posts', data: ids });
    expect(result).toEqual(mockResponse);
  });
});
```

#### 2.2 Write Component Tests

Create `index.test.ts` file in the `tagtag-ui/apps/tagtag/src/views/modules/system/post/__tests__` directory:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// Mock dependencies
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    // Mock Grid component
    { template: '<div></div>' },
    // Mock gridApi
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

describe('PostIndex Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(PostIndex);
    expect(wrapper.exists()).toBe(true);
  });
  
  it('should call handleAdd when add button is clicked', async () => {
    // Mock handleAdd method
    const handleAdd = vi.fn();
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // Trigger toolbar click event
    await wrapper.findComponent({ name: 'Grid' }).vm.$emit('toolbar-click', { code: 'add' });
    
    // Verify handleAdd was called
    expect(wrapper.vm.modalVisible).toBe(true);
  });
});
```

## Summary

Through the above steps, you have successfully developed a complete CRUD module with frontend-backend interaction and written corresponding test cases. Tagtag's modular design makes this process clear and standardized.

### Development Process Review

1. **Backend Development**:
   - Database design
   - Define contracts (DTO, Query)
   - Persistence layer implementation (Entity, Mapper)
   - Business layer implementation (Service)
   - Controller layer implementation (Controller)
   - Write unit tests

2. **Frontend Development**:
   - Define API requests
   - Create list page
   - Create form modal component
   - Configure menu
   - Write API tests and component tests

3. **Deployment and Verification**:
   - Start frontend and backend services
   - Log in to the system to verify functionality
   - Execute test cases

Congratulations! You have successfully developed a complete CRUD module with full frontend and backend interaction. Tagtag's modular design makes this process clear and standardized.
