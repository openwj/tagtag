---
title: Code Style and Best Practices
description: Code style and best practices guide for Tagtag project.
---

# Code Style and Best Practices

Good code style is an important means to ensure code quality, improve development efficiency, and reduce maintenance costs. This document summarizes the code style, naming conventions, and code review standards for Tagtag project, including Java backend and TypeScript frontend.

## 1. General Principles

The following general principles should be followed regardless of the programming language used:

### 1.1 Code Readability First

- Code is written for humans, not for machines
- Keep code simple, clear, and easy to understand
- Use meaningful names, avoid abbreviations and obscure names
- Add appropriate comments, but don't over-comment

### 1.2 Consistency

- Follow the project's existing code style
- Keep indentation, line breaks, spaces, etc. consistent
- Use a unified naming style

### 1.3 Modularity

- Split code into reusable modules
- Each module has a single responsibility
- Clear dependencies between modules

### 1.4 Test First

- Write testable code
- Write unit tests for core functionality
- Follow Test-Driven Development (TDD) principles

### 1.5 Security

- Avoid hardcoding sensitive information
- Pay attention to security issues such as SQL injection and XSS attacks
- Follow the principle of least privilege

## 2. Java Code Style

Tagtag backend is developed using Java language, following the code style below:

### 2.1 Naming Conventions

- **Class Names**: Use PascalCase, e.g., `UserService`, `PostController`
- **Method Names**: Use camelCase, e.g., `getUserById`, `savePost`
- **Variable Names**: Use camelCase, e.g., `userName`, `pageSize`
- **Constant Names**: Use UPPER_CASE_WITH_UNDERSCORES, e.g., `MAX_PAGE_SIZE`, `DEFAULT_STATUS`
- **Package Names**: Use lowercase letters, e.g., `dev.tagtag.common.util`
- **Interface Names**: Use PascalCase, e.g., `UserService`, `PostMapper`

### 2.2 Code Format

- **Indentation**: Use 4 spaces for indentation
- **Line Length**: Maximum 120 characters per line
- **Blank Lines**: Add appropriate blank lines between methods, code blocks, etc.
- **Brackets**: Opening bracket `{` on the same line as the statement, closing bracket `}` on a separate line
- **Spaces**:
  - Add spaces around operators, e.g., `a = b + c`
  - Add spaces after commas and semicolons, e.g., `method(a, b, c)`
  - No spaces inside brackets, e.g., `method(a, b)` instead of `method( a, b )`

### 2.3 Commenting Guidelines

- **Class Comments**: Use Javadoc comments to explain the purpose, author, creation date, etc.
  ```java
  /**
   * User service class, responsible for user-related business logic
   *
   * @author Tagtag Team
   * @since 2024-01-01
   */
  @Service
  public class UserService {
      // Class implementation
  }
  ```

- **Method Comments**: Use Javadoc comments to explain the purpose, parameters, return values, exceptions, etc.
  ```java
  /**
   * Get user information by ID
   *
   * @param userId User ID
   * @return User information
   * @throws BusinessException If user does not exist
   */
  public UserDTO getUserById(Long userId) {
      // Method implementation
  }
  ```

- **Line Comments**: Use `//` comments to explain complex logic or special handling
  ```java
  // Handle special case: when user has no avatar, use default avatar
  if (user.getAvatar() == null) {
      user.setAvatar(DEFAULT_AVATAR);
  }
  ```

### 2.4 Best Practices

- **Use Lombok to Simplify Code**: Use annotations like `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor` to simplify POJO classes
- **Avoid Magic Numbers**: Define constants as static constants, e.g., `private static final int MAX_RETRY = 3`
- **Use Optional to Handle null**: Avoid using null directly, wrap nullable values with Optional
- **Use try-with-resources to Manage Resources**: Automatically close resources to avoid memory leaks
- **Follow SOLID Principles**:
  - Single Responsibility Principle: A class should have only one responsibility
  - Open-Closed Principle: Open for extension, closed for modification
  - Liskov Substitution Principle: Subclasses can replace their parent classes
  - Interface Segregation Principle: Use multiple specialized interfaces instead of one general interface
  - Dependency Inversion Principle: Depend on abstractions, not concrete implementations

### 2.5 Spring Boot Best Practices

- **Use Constructor Injection**: Avoid field injection, improve testability
  ```java
  @Service
  @RequiredArgsConstructor
  public class UserServiceImpl implements UserService {
      private final UserMapper userMapper;
      private final RoleService roleService;
      // Method implementation
  }
  ```

- **Use @RestController Instead of @Controller + @ResponseBody**: Simplify REST interface development
- **Use @ExceptionHandler to Handle Exceptions**: Unify exception handling, improve code readability
- **Use @Validated for Parameter Validation**: Automatically validate request parameters, reduce duplicate code
- **Use @Transactional to Manage Transactions**: Clear transaction boundaries, ensure data consistency

## 3. TypeScript Code Style

Tagtag frontend is developed using TypeScript language, following the code style below:

### 3.1 Naming Conventions

- **Component Names**: Use PascalCase, e.g., `PostList`, `FormModal`
- **Variable Names**: Use camelCase, e.g., `userName`, `isLoading`
- **Function Names**: Use camelCase, e.g., `getUserInfo`, `handleSubmit`
- **Constant Names**: Use UPPER_CASE_WITH_UNDERSCORES, e.g., `MAX_PAGE_SIZE`, `API_BASE_URL`
- **Type Names**: Use PascalCase, e.g., `UserDTO`, `PostQuery`
- **Interface Names**: Use PascalCase, e.g., `UserService`, `PostApi`

### 3.2 Code Format

- **Indentation**: Use 2 spaces for indentation
- **Line Length**: Maximum 120 characters per line
- **Blank Lines**: Add appropriate blank lines between functions, code blocks, etc.
- **Brackets**: Opening bracket `{` on the same line as the statement, closing bracket `}` on a separate line
- **Spaces**:
  - Add spaces around operators, e.g., `a = b + c`
  - Add spaces after commas and semicolons, e.g., `method(a, b, c)`
  - No spaces inside brackets, e.g., `method(a, b)` instead of `method( a, b )`

### 3.3 Commenting Guidelines

- **Component Comments**: Use JSDoc comments to explain the purpose, props, events, etc.
  ```typescript
  /**
   * Post list component, displays post list and provides filtering, sorting functionality
   *
   * @component
   * @param {Object} props - Component props
   * @param {Function} onEdit - Edit post callback function
   * @param {Function} onDelete - Delete post callback function
   */
  export default defineComponent({
      // Component implementation
  });
  ```

- **Function Comments**: Use JSDoc comments to explain the purpose, parameters, return values, etc.
  ```typescript
  /**
   * Get post list
   *
   * @param {PostQuery} params - Query parameters
   * @returns {Promise<PageResult<PostDTO>>} Post list
   */
  export function getPostList(params: PostQuery): Promise<PageResult<PostDTO>> {
      // Function implementation
  }
  ```

- **Line Comments**: Use `//` comments to explain complex logic or special handling
  ```typescript
  // Handle special case: when post status is 0, display as draft
  const statusText = status === 1 ? 'Published' : 'Draft';
  ```

### 3.4 Best Practices

- **Use TypeScript Strict Mode**: Enable `strict: true` configuration to improve type safety
- **Avoid any Type**: Try to use specific types to improve code reliability
- **Use Interfaces to Define Data Structures**: Clear data types, improve code readability
- **Use const Instead of let**: Use const unless reassigning is needed
- **Use Arrow Functions**: Simplify function definitions, avoid this binding issues
- **Use Destructuring Assignment**: Simplify variable assignment, improve code readability
- **Use Template Strings**: Simplify string concatenation

### 3.5 Vue 3 Best Practices

- **Use Composition API**: Utilize setup syntax sugar to improve code organization and reusability
  ```vue
  <script setup lang="ts">
  import { ref, computed } from 'vue';
  
  const count = ref(0);
  const doubleCount = computed(() => count.value * 2);
  
  function increment() {
      count.value++;
  }
  </script>
  ```

- **Use defineProps and defineEmits**: Simplify component props and events definition
  ```typescript
  const props = defineProps<{
      title: string;
      visible: boolean;
  }>();
  
  const emit = defineEmits<{
      (e: 'close'): void;
      (e: 'save', data: FormData): void;
  }>();
  ```

- **Use watchEffect Instead of watch**: Simplify reactive data listening
- **Use provide/inject for Component Communication**: Avoid props drilling
- **Use Teleport for Modals**: Optimize modal positioning and styling
- **Use Suspense for Async Components**: Provide loading states and error handling

## 4. Naming Conventions

### 4.1 Package/Module Naming

- **Java Package Names**: Use lowercase letters, e.g., `dev.tagtag.common.util`
- **TypeScript Module Names**: Use lowercase letters, e.g., `@/api/modules/system/post`
- **Directory Names**: Use kebab-case, e.g., `user-management`, `post-list`

### 4.2 Class/Interface Naming

- **Java Class Names**: Use PascalCase, e.g., `UserService`, `PostController`
- **TypeScript Type Names**: Use PascalCase, e.g., `UserDTO`, `PostQuery`
- **Interface Names**: Use PascalCase, e.g., `UserRepository`, `PostService`

### 4.3 Method Naming

- **Get Data**: Use `get` or `find` prefix, e.g., `getUserById`, `findPosts`
- **Save Data**: Use `save` or `create` prefix, e.g., `saveUser`, `createPost`
- **Update Data**: Use `update` prefix, e.g., `updateUser`, `updatePost`
- **Delete Data**: Use `delete` prefix, e.g., `deleteUser`, `deletePost`
- **Query List**: Use `list` or `page` prefix, e.g., `listUsers`, `pagePosts`
- **Handle Events**: Use `handle` prefix, e.g., `handleSubmit`, `handleDelete`

### 4.4 Variable Naming

- **Boolean Variables**: Use `is` or `has` prefix, e.g., `isLoading`, `hasPermission`
- **Array Variables**: Use plural form, e.g., `users`, `posts`
- **Collection Variables**: Use specific collection types, e.g., `userList`, `postMap`
- **Constant Variables**: Use UPPER_CASE_WITH_UNDERSCORES, e.g., `MAX_PAGE_SIZE`, `DEFAULT_AVATAR`

## 5. Code Review Standards

Code review is an important part of ensuring code quality. Here are the code review standards for Tagtag project:

### 5.1 Review Content

- **Functional Correctness**: Whether the code implements the expected functionality
- **Code Style**: Whether it follows the project's code style
- **Code Readability**: Whether the code is easy to understand and maintain
- **Performance**: Whether there are performance issues, such as deep loop nesting, unnecessary calculations, etc.
- **Security**: Whether there are security vulnerabilities, such as SQL injection, XSS attacks, etc.
- **Test Coverage**: Whether test cases are written for core functionality
- **Dependency Relationships**: Whether the dependencies between modules are clear, whether there are circular dependencies

### 5.2 Review Process

1. **Before Submitting Code**:
   - Run local tests to ensure all tests pass
   - Run code formatting tools, such as Prettier
   - Run static code analysis tools, such as ESLint, SonarQube

2. **After Submitting Code**:
   - Create a Pull Request (PR)
   - Specify at least one reviewer
   - Fill in a clear PR description, including functionality, changes, test status, etc.

3. **Reviewer Review**:
   - Check if the code complies with standards
   - Provide modification suggestions
   - Approve or reject the PR

4. **Modify Code**:
   - Modify code according to reviewer's suggestions
   - Re-run tests and code analysis
   - Submit modifications

5. **Merge Code**:
   - After all reviewers approve, merge the PR
   - Delete temporary branches

### 5.3 Review Standards

- **Must Fix Issues**:
  - Syntax errors
  - Logic errors
  - Security vulnerabilities
  - Performance issues
  - Violations of basic design principles

- **Recommended Fix Issues**:
  - Code readability issues
  - Naming inconsistencies
  - Insufficient comments
  - Duplicate code
  - Optimizable code

### 5.4 Review Tips

- **Focus on Code Logic**: Don't get stuck on formatting details, use automated tools to solve them
- **Provide Specific Suggestions**: Don't just say "this place is bad", explain the specific problem and improvement plan
- **Be Constructive**: Use positive language, avoid criticism
- **Respect the Author**: Understand the author's design ideas, don't easily negate
- **Learn from Others' Code**: Learn good design and implementation from reviews

## 6. Git Best Practices

### 6.1 Branch Management

- **Main Branch (main)**: Stable production branch, only accepts merge requests
- **Develop Branch (develop)**: Development branch, contains the latest development code
- **Feature Branch (feature/xxx)**: Branch for developing new features, created from develop branch
- **Fix Branch (fix/xxx)**: Branch for fixing bugs, created from main branch
- **Release Branch (release/xxx)**: Branch for preparing releases, created from develop branch

### 6.2 Commit Message Standards

- **Clear Commit Messages**: Use concise and clear commit messages to explain the changes
- **Commit Message Format**:
  ```
  <type>(<scope>): <subject>
  
  <body>
  
  <footer>
  ```

  - **type**: Commit type, including feat(new feature), fix(bug fix), docs(documentation), style(style), refactor(refactoring), test(test), chore(build), etc.
  - **scope**: Modification scope, e.g., user, post, auth, etc.
  - **subject**: Short commit description, no more than 50 characters
  - **body**: Detailed commit description, explaining the reason and content of the modification
  - **footer**: Contains breaking changes or issue links

- **Example**:
  ```
  feat(user): Add user avatar upload functionality
  
  1. Add avatar upload interface
  2. Implement avatar cropping functionality
  3. Update user information page
  
  Closes #123
  ```

### 6.3 Commit Frequency

- **Commit Frequently**: Commit a small feature or fix a small bug each time
- **Avoid Large Commits**: Don't commit a lot of code at once, which is difficult to review and rollback
- **Keep Commit Atomicity**: Each commit should contain only one logical change

## 7. Summary

Good code style and best practices are important foundations for ensuring project quality. By following the standards and recommendations in this document, we can:

- Improve code readability and maintainability
- Reduce bugs and security vulnerabilities
- Improve development efficiency and collaboration efficiency
- Reduce long-term maintenance costs of the project

We hope all developers strictly follow these standards and best practices to jointly maintain a high-quality codebase.