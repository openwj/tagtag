---
title: Frontend Architecture
description: Detailed introduction to Tagtag frontend architecture.
---

Tagtag frontend adopts a modern architecture design, built on Vue 3 + TypeScript + Vite, and uses a Monorepo structure to manage code. This document will provide a detailed introduction to the design philosophy, technology stack, core components, and best practices of the frontend architecture.

## 1. Architecture Design Philosophy

Tagtag frontend architecture follows the following design principles:

### 1.1 Component-Based Design

Split the UI into reusable components, each responsible for an independent function, improving code reusability and maintainability.

### 1.2 Separation of Concerns

Separate business logic, UI presentation, and state management to make the code structure clear, easy to test and maintain.

### 1.3 Type Safety

Fully utilize TypeScript's static type checking to improve code quality and development efficiency.

### 1.4 Responsive Design

Adapt to devices with different screen sizes, providing a good user experience.

### 1.5 Performance Optimization

Adopt optimization methods such as code splitting, lazy loading, and virtual scrolling to improve application performance.

### 1.6 Scalability

Design flexible extension mechanisms for adding new features and integrating third-party libraries.

## 2. Technology Stack

| Technology | Version | Usage |
|------------|---------|-------|
| Vue 3 | 3.x | Reactive frontend framework, providing Composition API. |
| TypeScript | 5.x | Static type checking, improving code quality. |
| Vite | 5.x | Modern frontend build tool, providing fast development experience. |
| Pinia | 2.x | Official state management library for Vue 3. |
| Vue Router | 4.x | Official routing management library for Vue. |
| Tailwind CSS | 3.x | Utility-first CSS framework, improving style development efficiency. |
| Shadcn UI | latest | Customizable UI component library, based on Tailwind CSS. |
| pnpm | 10.x | Efficient package manager, supporting Monorepo structure. |
| Axios | 1.x | HTTP client for API requests. |
| Echarts | 5.x | Data visualization library. |

## 3. Monorepo Structure

Tagtag frontend uses a Monorepo structure to manage code, with pnpm as the package manager. The advantages of this structure include:

### 3.1 Code Sharing

Multiple applications can share components, utility classes, and configurations, reducing duplicate code.

### 3.2 Unified Dependency Management

All applications use the same version of dependencies, avoiding version conflicts.

### 3.3 Unified Build Tools

Shared build configurations and scripts, improving development efficiency.

### 3.4 Better Collaboration

Team members can more easily share and reuse code.

### 3.5 Simplified Version Management

Unified version number management, simplifying the release process.

## 4. Directory Structure

```
tagtag-ui
├── apps                  # Application Layer
│   └── tagtag            # Main Application
│       ├── public        # Static Resources
│       └── src           # Source Code
├── packages              # Core Package Layer
│   ├── @core             # Core Shared Library
│   │   ├── base          # Basic Design System, Icons, and Shared Tools
│   │   ├── composables   # Common Composable Functions
│   │   ├── preferences   # Application Preference Settings Management
│   │   └── ui-kit        # UI Component Library
│   ├── constants         # Constant Definitions
│   └── effects           # Business Side-effects and Logic Encapsulation
└── internal              # Internal Tools Layer
    ├── lint-configs      # Code Style Configurations
    ├── node-utils        # Node.js Utility Functions
    ├── tailwind-config   # Tailwind CSS Configuration
    ├── tsconfig          # TypeScript Configuration Files
    └── vite-config       # Vite Build Configuration
```

## 5. Core Modules

### 5.1 Application Layer (`apps`)

Contains specific application implementations, with each subdirectory corresponding to an independent frontend application.

#### 5.1.1 Main Application (`apps/tagtag`)

**Core Components**:

- `src/api/`: API request definitions and encapsulation
  - `core/`: Core APIs (authentication, user, menu)
  - `modules/`: Module APIs (IAM, system, storage)
  - `request.ts`: Axios instance configuration

- `src/views/`: Page view components
  - `_core/`: Core pages (login, personal center, 404, etc.)
  - `dashboard/`: Dashboard pages
  - `modules/`: Module pages (IAM, system, storage)

- `src/router/`: Routing configuration
  - `routes/`: Route definitions
  - `access.ts`: Route guards
  - `guard.ts`: Permission guards

- `src/store/`: Pinia state management
  - `auth.ts`: Authentication state management

- `src/layouts/`: Layout components
  - `auth.vue`: Authentication layout
  - `basic.vue`: Basic layout

- `src/components/`: Business components

- `src/locales/`: Internationalization configuration
  - `langs/`: Language packs

### 5.2 Core Package Layer (`packages`)

Provides reusable core functions and components for the application layer.

**Submodules**:

#### 5.2.1 Core Shared Library (`packages/@core`)

**Submodules**:

- **`base`**: Basic design system, icons, and shared utilities
  - `design/`: Design system and design tokens
  - `icons/`: Icon library
  - `shared/`: Shared utility classes
  - `typings/`: Type definitions

- **`composables`**: Common composable functions
  - `use-is-mobile.ts`: Mobile device detection
  - `use-layout-style.ts`: Layout style management
  - `use-namespace.ts`: Namespace management
  - `use-scroll-lock.ts`: Scroll lock management
  - `use-sortable.ts`: Sorting functionality

- **`preferences`**: Application preference settings management
  - Theme settings
  - Layout settings
  - Other user preferences

- **`ui-kit`**: Encapsulated UI component library
  - `shadcn-ui`: Base components based on Shadcn UI
  - `form-ui`: Form component encapsulation
  - `layout-ui`: Layout component encapsulation
  - `popup-ui`: Popup, drawer, and other component encapsulation
  - `tabs-ui`: Tab component encapsulation
  - `menu-ui`: Menu component encapsulation

#### 5.2.2 Constant Definitions (`packages/constants`)

- Core constant definitions
- Business constant definitions

#### 5.2.3 Business Side-effects and Logic (`packages/effects`)

- **`access`**: Permission control logic
  - Permission directives
  - Permission components
  - Permission management

- **`common-ui`**: Common UI components
  - About page
  - Fallback pages
  - Profile components

- **`hooks`**: Common Hooks
  - `use-app-config.ts`: Application configuration management
  - `use-content-maximize.ts`: Content maximize management
  - `use-design-tokens.ts`: Design token management
  - `use-hover-toggle.ts`: Hover toggle management
  - `use-pagination.ts`: Pagination management
  - `use-refresh.ts`: Refresh functionality
  - `use-tabs.ts`: Tab management
  - `use-watermark.ts`: Watermark functionality

- **`layouts`**: Layout components
  - Basic layout
  - Authentication layout
  - Iframe layout

- **`plugins`**: Third-party plugin integration
  - `echarts`: ECharts integration
  - `motion`: Animation integration
  - `vxe-table`: Table integration

### 5.3 Internal Tools Layer (`internal`)

Provides tools and configurations for building, development, and maintenance.

**Core Components**:

- `lint-configs/`: ESLint, Prettier, Stylelint, etc. code style configurations
- `node-utils/`: Node.js utility functions
- `tailwind-config/`: Tailwind CSS configuration encapsulation
- `tsconfig/`: TypeScript configuration files
  - `base.json`: Base TypeScript configuration
  - `library.json`: Library TypeScript configuration
  - `node.json`: Node.js TypeScript configuration
  - `web-app.json`: Web application TypeScript configuration
  - `web.json`: Web TypeScript configuration
- `vite-config/`: Vite build configuration encapsulation
  - Application configuration
  - Library configuration
  - Plugin configuration

## 6. Data Flow Design

### 6.1 State Management

Use Pinia for state management, dividing application state into multiple modules, each responsible for an independent functional domain.

**State Management Process**:

1. Components obtain state through the `useStore` hook
2. Components call actions to modify state
3. Actions can call APIs to obtain data
4. Mutations modify state (in Pinia, actions can directly modify state)
5. State changes trigger component re-rendering

### 6.2 API Request Flow

1. Components call API functions
2. API functions use the encapsulated Axios instance to send requests
3. Request interceptors add authentication information and other headers
4. Backend processes the request and returns a response
5. Response interceptors process the response and uniformly handle errors
6. API functions return response data
7. Components process response data, update state or UI

### 6.3 Routing Flow

1. User accesses a route
2. Route guards check user permissions
3. After permission is granted, the corresponding component is loaded
4. Component obtains data and renders the page

## 7. Permission Control

Tagtag frontend implements Role-Based Access Control (RBAC), including:

### 7.1 Route Permission

- Dynamic route generation: Generate accessible routes based on user roles
- Route guards: Check if the user has permission to access a route

### 7.2 Component Permission

- Permission directive: Use the `v-access` directive to control component display and hiding
- Permission component: Use the `AccessControl` component to control display and hiding of child components

### 7.3 Button Permission

- Button permission directive: Use the `v-access` directive to control button display and hiding

## 8. Internationalization Support

Tagtag frontend supports multi-language switching, implemented using Vue I18n.

**Internationalization Configuration**:

- `src/locales/langs/`: Language pack files
- `src/locales/index.ts`: Internationalization configuration

**Usage**:

```vue
<template>
  <div>{{ $t('common.save') }}</div>
</template>

<script setup lang="ts">
import { useI18n } from 'vue-i18n'
const { t } = useI18n()
</script>
```

## 9. Build and Deployment

### 9.1 Build Process

1. Install dependencies: `pnpm install`
2. Development mode: `pnpm run dev`
3. Production build: `pnpm run build`
4. Preview production build: `pnpm run preview`

### 9.2 Build Optimization

- Code splitting: Split code based on routes and components
- Lazy loading: Load routes and components on demand
- Tree Shaking: Remove unused code
- Compression: Compress JavaScript, CSS, and HTML

### 9.3 Deployment Methods

- Static file deployment: Deploy built static files to CDN or web server
- Docker deployment: Deploy applications using Docker containers
- Kubernetes deployment: Manage containerized applications using Kubernetes

## 10. Best Practices

### 10.1 Component Development

- Component naming: Use PascalCase to name components
- Component responsibility: Each component is responsible for an independent function
- Component communication: Use Props and Emits for component communication
- Component testing: Write unit tests for components

### 10.2 API Development

- API naming: Use RESTful API style
- API encapsulation: Uniformly encapsulate API requests, handle errors and authentication
- API documentation: Use Swagger or other tools to generate API documentation

### 10.3 State Management

- State design: Keep state concise and avoid redundancy
- State division: Divide state modules according to functional domains
- Asynchronous processing: Handle asynchronous logic in actions

### 10.4 Performance Optimization

- Avoid unnecessary rendering: Use `v-memo` and `v-once` directives
- Virtual scrolling: Use virtual scrolling when handling large amounts of data
- Image optimization: Use appropriate image formats and sizes
- Lazy loading: Load routes and components on demand

### 10.5 Code Style

- Follow ESLint and Prettier configurations
- Use TypeScript strict mode
- Comment规范: Add comments for complex code

## 11. Development Tools and Process

### 11.1 Development Tools

- VS Code: Recommended code editor
- Volar: Vue 3 development plugin
- ESLint: Code quality checking
- Prettier: Code formatting

### 11.2 Development Process

1. Clone the code repository
2. Install dependencies
3. Start the development server
4. Write code
5. Run tests
6. Commit code
7. Code review
8. Merge code
9. Build and deploy

## 12. Testing Strategy

### 12.1 Unit Testing

Use Vitest for unit testing, testing components, utility functions, and state management.

### 12.2 Integration Testing

Test interactions between components and API calls.

### 12.3 E2E Testing

Use Cypress for end-to-end testing, testing complete user flows.

## 13. Monitoring and Logging

### 13.1 Application Monitoring

- Use Sentry or other tools to monitor application errors
- Collect user behavior data to analyze application usage

### 13.2 Logging

- Record application errors and warnings
- Record key operation logs
- Use log analysis tools to analyze logs

## 14. Future Planning

- Support micro-frontend architecture
- Enhance TypeScript type support
- Optimize performance and user experience
- Add more UI components and templates
- Support more international languages

# Summary

Tagtag frontend architecture adopts modern design philosophy and technology stack, built on Vue 3 + TypeScript + Vite, and uses Monorepo structure to manage code. This architecture design has good scalability, maintainability, and performance, suitable for building complex enterprise-level applications.

Through the introduction of this document, you should have a comprehensive understanding of the Tagtag frontend architecture. If you want to learn more about a specific module or component, you can check the relevant source code and documentation.