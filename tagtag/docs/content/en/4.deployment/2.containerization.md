---
title: Containerization Deployment
description: Tagtag containerization deployment guide, including Docker and Kubernetes deployment solutions.
---

Containerization is the trend of modern application deployment. The Tagtag project supports Docker and Kubernetes deployment. This document will detail the containerization deployment solutions and best practices.

## 1. Containerization Overview

### 1.1 Why Choose Containerization

- **Consistency**: Containers ensure consistent application runtime across different environments
- **Lightweight**: Containers are lighter than virtual machines and start faster
- **Portability**: Containers can run in any environment that supports Docker
- **Scalability**: Containers are easy to scale horizontally, supporting automated operation and maintenance
- **Resource Isolation**: Containers provide good resource isolation mechanisms
- **Version Control**: Container images support version control, facilitating rollback and management

### 1.2 Technology Stack

| Technology | Purpose |
|------------|---------|
| Docker | Container runtime and image building |
| Docker Compose | Local development and testing environment deployment |
| Kubernetes | Production environment container orchestration |
| Helm | Kubernetes application package management |
| GitHub Actions | CI/CD automated deployment |
| Harbor | Private Docker image registry |

## 2. Docker Deployment

### 2.1 Dockerfile Writing

#### 2.1.1 Backend Dockerfile

```dockerfile
# Use Java 17 as base image
FROM openjdk:17-jdk-slim as builder

# Set working directory
WORKDIR /app

# Copy Maven configuration files
COPY pom.xml .
COPY .mvn .mvn

# Download dependencies
RUN ./mvnw dependency:go-offline

# Copy source code
COPY src src

# Build project
RUN ./mvnw package -DskipTests

# Use lightweight base image
FROM openjdk:17-jdk-slim

# Set working directory
WORKDIR /app

# Copy JAR file from build stage
COPY --from=builder /app/target/tagtag-backend.jar .

# Set environment variables
ENV JAVA_OPTS="-Xmx8g -Xms4g"
ENV SPRING_PROFILES_ACTIVE=prod

# Expose port
EXPOSE 8080

# Start application
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar tagtag-backend.jar"]
```

#### 2.1.2 Frontend Dockerfile

```dockerfile
# Use Node.js 18 as base image
FROM node:18-alpine as builder

# Set working directory
WORKDIR /app

# Copy package.json and pnpm-lock.yaml
COPY package.json pnpm-lock.yaml ./

# Install pnpm
RUN npm install -g pnpm

# Install dependencies
RUN pnpm install

# Copy source code
COPY . .

# Build production version
RUN pnpm build

# Use Nginx as base image
FROM nginx:alpine

# Copy built static files to Nginx directory
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy Nginx configuration file
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port
EXPOSE 80

# Start Nginx
ENTRYPOINT ["nginx", "-g", "daemon off;"]
```

#### 2.1.3 Nginx Configuration

```nginx
server {
    listen 80;
    server_name localhost;
    
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### 2.2 Docker Compose Configuration

```yaml
version: '3.8'

networks:
  tagtag-network:
    driver: bridge

volumes:
  mysql-data:
  redis-data:
  logs:

services:
  # MySQL database
  mysql:
    image: mysql:8.0
    container_name: tagtag-mysql
    restart: always
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=tagtag
      - MYSQL_CHARSET=utf8mb4
      - MYSQL_COLLATION=utf8mb4_unicode_ci
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql/conf:/etc/mysql/conf.d
      - ./mysql/init:/docker-entrypoint-initdb.d
    networks:
      - tagtag-network
    command: --default-authentication-plugin=mysql_native_password

  # Redis cache
  redis:
    image: redis:7.0-alpine
    container_name: tagtag-redis
    restart: always
    environment:
      - REDIS_PASSWORD=password
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - tagtag-network
    command: redis-server --requirepass password --appendonly yes

  # Backend application
  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: tagtag-backend
    restart: always
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
      - SPRING_DATASOURCE_USERNAME=root
      - SPRING_DATASOURCE_PASSWORD=password
      - SPRING_REDIS_HOST=redis
      - SPRING_REDIS_PORT=6379
      - SPRING_REDIS_PASSWORD=password
      - JWT_SECRET=your-secret-key
    ports:
      - "8080:8080"
    volumes:
      - logs:/app/logs
    networks:
      - tagtag-network
    depends_on:
      - mysql
      - redis

  # Frontend application
  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    container_name: tagtag-frontend
    restart: always
    ports:
      - "80:80"
    networks:
      - tagtag-network
    depends_on:
      - backend

  # Optional: phpMyAdmin (for database management)
  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    container_name: tagtag-phpmyadmin
    restart: always
    environment:
      - PMA_HOST=mysql
      - PMA_PORT=3306
      - MYSQL_ROOT_PASSWORD=password
    ports:
      - "8081:80"
    networks:
      - tagtag-network
    depends_on:
      - mysql

  # Optional: Redis Commander (for Redis management)
  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: tagtag-redis-commander
    restart: always
    environment:
      - REDIS_HOSTS=local:redis:6379:0:password
    ports:
      - "8082:8081"
    networks:
      - tagtag-network
    depends_on:
      - redis
```

### 2.3 Build and Run

**Command Examples**:

```bash
# Enter Docker Compose directory
cd docker

# Build all services
docker-compose build

# Run all services
docker-compose up -d

# Check service status
docker-compose ps

# Check logs
docker-compose logs -f

# Stop services
docker-compose down

# Stop services and delete volumes
docker-compose down -v

# Build only specific service
docker-compose build frontend

# Run only specific services
docker-compose up -d backend mysql redis
```

## 3. Kubernetes Deployment

### 3.1 Kubernetes Cluster Setup

#### 3.1.1 Local Development Environment

**Using Minikube**:

```bash
# Install Minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# Start Minikube
minikube start --cpus 4 --memory 8g --disk-size 40g

# Install kubectl
sudo apt-get update && sudo apt-get install -y kubectl

# Verify cluster
kubectl cluster-info
kubectl get nodes
```

**Using Kind**:

```bash
# Install Kind
go install sigs.k8s.io/kind@v0.20.0

# Create cluster configuration
cat > kind-config.yaml << EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 30080
    hostPort: 80
    protocol: TCP
  - containerPort: 30443
    hostPort: 443
    protocol: TCP
EOF

# Create cluster
kind create cluster --config kind-config.yaml

# Verify cluster
kubectl cluster-info
kubectl get nodes
```

#### 3.1.2 Production Environment

- **Cloud Provider Managed Clusters**: Recommended to use AWS EKS, Azure AKS, Google GKE, or Alibaba Cloud ACK
- **Self-built Clusters**: Use kubeadm or Rancher to set up

### 3.2 Kubernetes Resource Configuration

#### 3.2.1 Namespace

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: tagtag
  labels:
    name: tagtag
```

#### 3.2.2 Configuration File (ConfigMap)

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: tagtag-config
  namespace: tagtag
data:
  application-prod.yaml: |
    server:
      port: 8080
      servlet:
        context-path: /api
    spring:
      datasource:
        url: jdbc:mysql://mysql.tagtag:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
        username: root
        password: ${MYSQL_PASSWORD}
      redis:
        host: redis.tagtag
        port: 6379
        password: ${REDIS_PASSWORD}
    jwt:
      secret: ${JWT_SECRET}
      expiration: 3600
```

#### 3.2.3 Secrets

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: tagtag-secrets
  namespace: tagtag
type: Opaque
stringData:
  mysql-password: password
  redis-password: password
  jwt-secret: your-secret-key
```

#### 3.2.4 MySQL Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: tagtag
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: mysql-password
        - name: MYSQL_DATABASE
          value: tagtag
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
        - name: mysql-conf
          mountPath: /etc/mysql/conf.d
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc
      - name: mysql-conf
        configMap:
          name: mysql-config
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: tagtag
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
  clusterIP: None  # Use Headless Service
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: tagtag
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

#### 3.2.5 Redis Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: tagtag
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7.0-alpine
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: redis-password
        ports:
        - containerPort: 6379
        volumeMounts:
        - name: redis-data
          mountPath: /data
        command:
        - redis-server
        - --requirepass
        - $(REDIS_PASSWORD)
        - --appendonly
        - "yes"
      volumes:
      - name: redis-data
        persistentVolumeClaim:
          claimName: redis-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: tagtag
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-pvc
  namespace: tagtag
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

#### 3.2.6 Backend Application Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: tagtag
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: tagtag/backend:latest
        env:
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: mysql-password
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: redis-password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: jwt-secret
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /api/actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /api/actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        resources:
          requests:
            memory: "4Gi"
            cpu: "2"
          limits:
            memory: "8Gi"
            cpu: "4"
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: config
          mountPath: /app/config
      volumes:
      - name: logs
        emptyDir: {}
      - name: config
        configMap:
          name: tagtag-config
---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: tagtag
spec:
  selector:
    app: backend
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
```

#### 3.2.7 Frontend Application Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: tagtag
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: tagtag/frontend:latest
        ports:
        - containerPort: 80
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: tagtag
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

#### 3.2.8 Ingress Configuration

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tagtag-ingress
  namespace: tagtag
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
spec:
  ingressClassName: nginx
  rules:
  - host: tagtag.your-domain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: backend
            port:
              number: 8080
```

### 3.3 Helm Chart Configuration

#### 3.3.1 Chart Directory Structure

```
tagtag-chart/
├── Chart.yaml          # Chart metadata
├── values.yaml         # Default configuration values
├── templates/          # Template files
│   ├── _helpers.tpl    # Helper functions
│   ├── configmap.yaml  # ConfigMap template
│   ├── secret.yaml     # Secret template
│   ├── mysql/          # MySQL-related templates
│   ├── redis/          # Redis-related templates
│   ├── backend/        # Backend application templates
│   ├── frontend/       # Frontend application templates
│   └── ingress.yaml    # Ingress template
└── charts/             # Dependent Charts
```

#### 3.3.2 Chart.yaml

```yaml
apiVersion: v2
name: tagtag
description: A Helm chart for Tagtag application
type: application
version: 1.0.0
appVersion: "1.0.0"
dependencies:
  - name: mysql
    version: "8.8.2"
    repository: "https://charts.bitnami.com/bitnami"
    condition: mysql.enabled
  - name: redis
    version: "17.10.2"
    repository: "https://charts.bitnami.com/bitnami"
    condition: redis.enabled
```

#### 3.3.3 values.yaml

```yaml
# Global configuration
global:
  namespace: tagtag
  imageRegistry: ""

# Frontend configuration
frontend:
  replicaCount: 3
  image:
    repository: tagtag/frontend
    tag: latest
    pullPolicy: IfNotPresent
  resources:
    requests:
      memory: "512Mi"
      cpu: "250m"
    limits:
      memory: "1Gi"
      cpu: "500m"

# Backend configuration
backend:
  replicaCount: 3
  image:
    repository: tagtag/backend
    tag: latest
    pullPolicy: IfNotPresent
  resources:
    requests:
      memory: "4Gi"
      cpu: "2"
    limits:
      memory: "8Gi"
      cpu: "4"

# MySQL configuration
mysql:
  enabled: true
  auth:
    rootPassword: password
    database: tagtag
  primary:
    persistence:
      size: 20Gi

# Redis configuration
redis:
  enabled: true
  auth:
    password: password
  master:
    persistence:
      size: 10Gi

# Ingress configuration
ingress:
  enabled: true
  className: nginx
  hosts:
    - host: tagtag.your-domain.com
      paths:
        - path: /
          pathType: Prefix
        - path: /api
          pathType: Prefix
```

#### 3.3.4 Deploying with Helm

```bash
# Install Helm
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

# Add Helm repository
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# Install Chart
helm install tagtag ./tagtag-chart -n tagtag --create-namespace

# Update Chart
helm upgrade tagtag ./tagtag-chart -n tagtag

# Uninstall Chart
helm uninstall tagtag -n tagtag

# List installed Charts
helm list -n tagtag

# Check Chart status
helm status tagtag -n tagtag

# Check Pod status
kubectl get pods -n tagtag

# Check logs
kubectl logs -f <pod-name> -n tagtag
```

### 3.4 CI/CD Integration

#### 3.4.1 GitHub Actions Configuration

```yaml
name: CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  # Build backend
  build-backend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package -DskipTests --file backend/pom.xml
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}
    
    - name: Build and push backend image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-backend:${{ github.sha }},${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-backend:latest

  # Build frontend
  build-frontend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js 18
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'pnpm'
    
    - name: Install pnpm
      run: npm install -g pnpm
    
    - name: Install dependencies
      run: pnpm install
      working-directory: ./frontend
    
    - name: Build frontend
      run: pnpm build
      working-directory: ./frontend
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-frontend:${{ github.sha }},${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-frontend:latest

  # Deploy to Kubernetes
  deploy:
    needs: [ build-backend, build-frontend ]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.25.0'
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Update kubeconfig
      run: aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
    
    - name: Deploy to Kubernetes
      run: |
        # Update image version in Helm Chart
        sed -i 's|tag: latest|tag: ${{ github.sha }}|g' ./helm/values.yaml
        
        # Deploy application
        helm upgrade --install tagtag ./helm -n tagtag --create-namespace
    
    - name: Verify deployment
      run: |
        kubectl wait --for=condition=available deployment/backend -n tagtag --timeout=300s
        kubectl wait --for=condition=available deployment/frontend -n tagtag --timeout=300s
        kubectl get pods -n tagtag
```

## 4. Best Practices

### 4.1 Docker Best Practices

- **Use Lightweight Base Images**: Such as alpine or slim versions
- **Minimize Image Layers**: Combine RUN instructions, use multi-stage builds
- **Use .dockerignore File**: Exclude unnecessary files and directories
- **Run Containers as Non-root User**: Improve security
- **Set Reasonable Health Checks**: Use HEALTHCHECK instruction
- **Set Reasonable Resource Limits**: Avoid containers taking up too many resources
- **Use Tags to Manage Images**: Include version numbers, commit hashes, etc.
- **Avoid Storing Data in Containers**: Use volumes or external storage

### 4.2 Kubernetes Best Practices

- **Use Namespaces**: Divide resources by environment or team
- **Set Reasonable Resource Requests and Limits**: Ensure cluster stability
- **Use Health Checks and Readiness Probes**: Improve application availability
- **Use Rolling Updates**: Ensure zero downtime deployment
- **Use StatefulSet for Stateful Applications**: Such as databases
- **Use ConfigMap and Secret for Configuration Management**: Avoid hardcoding
- **Use Horizontal Pod Autoscaler**: Auto-scaling
- **Use NetworkPolicy to Restrict Network Access**: Improve security
- **Regular Data Backup**: Use CronJob or external tools
- **Monitoring and Log Collection**: Use Prometheus and ELK Stack

### 4.3 CI/CD Best Practices

- **Automated Testing**: Run unit tests and integration tests before building
- **Code Quality Checking**: Use ESLint, SonarQube, etc.
- **Image Security Scanning**: Use Trivy or Clair to scan image vulnerabilities
- **Multi-environment Deployment**: Development, testing, staging, production environments
- **Manual Approval**: Production environment deployment requires manual approval
- **Rollback Mechanism**: Support quick rollback to previous versions
- **Monitor Deployment Status**: Real-time monitoring of deployment progress and status
- **Log Collection**: Collect logs of CI/CD processes

## 5. Common Issues and Solutions

### 5.1 Docker-related Issues

#### 5.1.1 Image Build Failure

**Problem**: Dependency installation failure during image building

**Solutions**:
- Check network connection
- Check dependency sources in Dockerfile
- Use domestic image sources to accelerate dependency downloads
- Clean cache and rebuild

#### 5.1.2 Container Startup Failure

**Problem**: Container exits immediately after startup

**Solutions**:
- Check container logs: `docker logs <container-name>`
- Check environment variable configuration
- Check port occupancy
- Check mounted volumes and configuration files

### 5.2 Kubernetes-related Issues

#### 5.2.1 Pod in Pending State

**Problem**: Pod remains in Pending state

**Solutions**:
- Check if cluster resources are sufficient
- Check if PersistentVolumeClaim is bound successfully
- Check NodeSelector and Toleration configuration
- Check events: `kubectl describe pod <pod-name> -n <namespace>`

#### 5.2.2 Pod in CrashLoopBackOff State

**Problem**: Pod restarts repeatedly

**Solutions**:
- Check container logs: `kubectl logs <pod-name> -n <namespace>`
- Check application configuration
- Check health check configuration
- Check if resource limits are reasonable

#### 5.2.3 Ingress Inaccessible

**Problem**: Cannot access application through Ingress

**Solutions**:
- Check if Ingress Controller is running normally
- Check Ingress rule configuration
- Check if Service is normal
- Check if Pod is running normally
- Check Ingress logs

## 6. Summary

Containerization deployment is the trend of modern application deployment. The Tagtag project supports Docker and Kubernetes deployment, providing flexible deployment solutions. Docker Compose can be used to quickly set up local development and testing environments, while Kubernetes and Helm can be used to achieve automated deployment and management in production environments.

This document details the containerization deployment solutions for the Tagtag project, including Dockerfile writing, Docker Compose configuration, Kubernetes resource configuration, Helm Chart configuration, and CI/CD integration. Following the best practices in this document can improve application availability, scalability, and security.

In the actual deployment process, it is recommended to flexibly adjust configuration parameters according to business requirements and cluster scale to ensure high performance and reliability of the system.