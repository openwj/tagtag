---
title: Production Deployment
description: Tagtag production environment deployment guide, including server configuration, database optimization, and security configuration.
---

# Production Deployment

This document details the deployment configuration of the Tagtag project in the production environment, including server selection, backend deployment, frontend deployment, database optimization, and security configuration.

## 1. Server Selection and Configuration

### 1.1 Server Architecture

Tagtag adopts a front-end and back-end separation architecture. The following server configuration is recommended for the production environment:

| Service Type | Recommended Configuration | Quantity | Purpose |
|--------------|----------------------------|----------|---------|
| Load Balancer | 4-core 8G | 1 | Traffic distribution, SSL termination |
| Backend Application | 8-core 16G | 2+ | Run Spring Boot applications |
| Frontend Application | 4-core 8G | 2 | Run Nginx services, deploy static resources |
| Database | 16-core 32G | 1 master 1 slave | Run MySQL database |
| Redis | 4-core 8G | 1 master 1 slave | Cache, session storage |
| Monitoring | 4-core 8G | 1 | Run Prometheus, Grafana and other monitoring tools |

### 1.2 Operating System Configuration

It is recommended to use CentOS 7.9 or Ubuntu 20.04 LTS as the server operating system.

**System Optimization Suggestions**:

```bash
# Stop unnecessary services
systemctl stop firewalld
systemctl disable firewalld
systemctl stop postfix
systemctl disable postfix

# Set system timezone
timedatectl set-timezone Asia/Shanghai

# Disable SELinux
sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
setenforce 0

# Optimize file descriptor limits
cat >> /etc/security/limits.conf << EOF
* soft nofile 65535
* hard nofile 65535
EOF

# Optimize kernel parameters
cat >> /etc/sysctl.conf << EOF
# Network optimization
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.ip_local_port_range = 1024 65535

# Memory optimization
vm.swappiness = 10
vm.overcommit_memory = 1
EOF

# Apply kernel parameters
sysctl -p
```

## 2. Backend Deployment

### 2.1 Build and Package

**Steps**:

1. Clone the code repository
2. Configure environment variables
3. Build the Maven project
4. Generate Docker image (optional)

**Command Example**:

```bash
# Clone code
git clone https://github.com/your-org/tagtag.git
cd tagtag

# Configure environment variables
export MAVEN_OPTS="-Xmx2g -Xms1g"

# Build project
mvn clean package -DskipTests

# Generate Docker image (optional)
docker build -t tagtag/backend:latest .
```

### 2.2 Deployment Methods

#### 2.2.1 Traditional Deployment

**Steps**:

1. Upload the built JAR file to the server
2. Create a startup script
3. Configure Systemd service
4. Start the service

**Example**:

```bash
# Create deployment directory
mkdir -p /opt/tagtag/backend
cd /opt/tagtag/backend

# Upload JAR file
scp target/tagtag-backend.jar root@server:/opt/tagtag/backend/

# Create startup script
cat > start.sh << EOF
#!/bin/bash
java -jar -Xmx8g -Xms4g -Dspring.profiles.active=prod tagtag-backend.jar
EOF

chmod +x start.sh

# Configure Systemd service
cat > /etc/systemd/system/tagtag-backend.service << EOF
[Unit]
Description=Tagtag Backend Service
After=network.target

[Service]
User=root
WorkingDirectory=/opt/tagtag/backend
ExecStart=/opt/tagtag/backend/start.sh
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# Start service
systemctl daemon-reload
systemctl start tagtag-backend
systemctl enable tagtag-backend
```

#### 2.2.2 Docker Deployment

**Steps**:

1. Install Docker
2. Pull or build Docker image
3. Create Docker Compose file
4. Start the service

**Docker Compose Example**:

```yaml
version: '3.8'

services:
  tagtag-backend:
    image: tagtag/backend:latest
    container_name: tagtag-backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_USERNAME=root
      - DB_PASSWORD=password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - mysql
      - redis
    restart: always
    volumes:
      - ./logs:/opt/tagtag/logs

  mysql:
    image: mysql:8.0
    container_name: mysql
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=tagtag
    restart: always
    volumes:
      - ./mysql/data:/var/lib/mysql
      - ./mysql/conf:/etc/mysql/conf.d

  redis:
    image: redis:7.0
    container_name: redis
    ports:
      - "6379:6379"
    restart: always
    volumes:
      - ./redis/data:/data
```

### 2.3 Configuration File Management

**Production environment configuration file**: `application-prod.yml`

**Core configuration items**:

```yaml
# Server configuration
server:
  port: 8080
  servlet:
    context-path: /api
  tomcat:
    threads:
      max: 200
      min-spare: 10
    connection-timeout: 30000

# Database configuration
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: password
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

# Redis configuration
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 100
        max-idle: 20
        min-idle: 5
        max-wait: -1ms

# JWT configuration
jwt:
  secret: your-secret-key
  expiration: 3600
  refresh-expiration: 86400

# Log configuration
logging:
  level:
    root: info
    com.tagtag: debug
  file:
    name: /opt/tagtag/logs/tagtag.log
    max-size: 100MB
    max-history: 30
```

## 3. Frontend Deployment

### 3.1 Build and Package

**Steps**:

1. Clone the code repository
2. Install dependencies
3. Build the production version
4. Generate Docker image (optional)

**Command Example**:

```bash
# Clone code
git clone https://github.com/your-org/tagtag.git
cd tagtag/tagtag-ui

# Install dependencies
pnpm install

# Build production version
pnpm build

# Generate Docker image (optional)
docker build -t tagtag/frontend:latest .
```

### 3.2 Nginx Deployment

**Steps**:

1. Install Nginx
2. Configure Nginx virtual host
3. Copy the built static files to the Nginx directory
4. Start the Nginx service

**Example**:

```bash
# Install Nginx
yum install -y nginx

# Create deployment directory
mkdir -p /usr/share/nginx/html/tagtag

# Copy static files
cp -r dist/* /usr/share/nginx/html/tagtag/

# Configure Nginx
cat > /etc/nginx/conf.d/tagtag.conf << EOF
server {
    listen 80;
    server_name tagtag.your-domain.com;
    
    # Static resource configuration
    location / {
        root /usr/share/nginx/html/tagtag;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    # API proxy configuration
    location /api {
        proxy_pass http://backend-server:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
    # Log configuration
    access_log /var/log/nginx/tagtag.access.log main;
    error_log /var/log/nginx/tagtag.error.log error;
}
EOF

# Check Nginx configuration
nginx -t

# Restart Nginx
systemctl restart nginx
systemctl enable nginx
```

### 3.3 SSL Configuration

**Steps**:

1. Apply for an SSL certificate (recommended: Let's Encrypt)
2. Configure Nginx SSL
3. Force HTTPS redirection

**Example**:

```bash
# Install Certbot
yum install -y epel-release
yum install -y certbot python3-certbot-nginx

# Apply for SSL certificate
certbot --nginx -d tagtag.your-domain.com

# Automatic renewal
echo "0 3 * * * certbot renew --quiet" >> /var/spool/cron/root
```

**Nginx SSL Configuration**:

```nginx
server {
    listen 443 ssl http2;
    server_name tagtag.your-domain.com;
    
    # SSL configuration
    ssl_certificate /etc/letsencrypt/live/tagtag.your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/tagtag.your-domain.com/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;
    ssl_session_tickets off;
    
    # TLS configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # HSTS configuration
    add_header Strict-Transport-Security "max-age=63072000" always;
    
    # Other configurations...
}

# Force HTTPS redirection
server {
    listen 80;
    server_name tagtag.your-domain.com;
    return 301 https://$server_name$request_uri;
}
```

## 4. Database Optimization

### 4.1 MySQL Configuration Optimization

**Core configuration items**:

```ini
# /etc/my.cnf

[mysqld]
# Basic configuration
user = mysql
datadir = /var/lib/mysql
socket = /var/lib/mysql/mysql.sock
pid-file = /var/run/mysqld/mysqld.pid

# Character set configuration
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci
init_connect = 'SET NAMES utf8mb4'

# Memory configuration
innodb_buffer_pool_size = 20G  # Recommended: 50%-70% of server memory
innodb_log_buffer_size = 128M
key_buffer_size = 256M
query_cache_size = 0
query_cache_type = 0

# Connection configuration
max_connections = 2000
max_connect_errors = 10000
wait_timeout = 600
interactive_timeout = 600

# InnoDB configuration
innodb_file_per_table = 1
innodb_flush_log_at_trx_commit = 2  # Recommended: 2 for production environment
innodb_log_file_size = 2G
innodb_log_files_in_group = 2
innodb_io_capacity = 4000
innodb_io_capacity_max = 8000
innodb_doublewrite = 1
innodb_thread_concurrency = 0

# Log configuration
slow_query_log = 1
slow_query_log_file = /var/lib/mysql/slow.log
long_query_time = 2
log_queries_not_using_indexes = 0

# Other configuration
skip-name-resolve
lower_case_table_names = 1
```

### 4.2 Index Optimization

**Index Design Principles**:

- Create indexes for frequently queried fields
- Create indexes for JOIN condition fields
- Create indexes for ORDER BY and GROUP BY fields
- Avoid creating too many indexes
- When using composite indexes, put the most frequently used fields first
- Regularly optimize tables and rebuild indexes

**Example**:

```sql
-- Create composite index
CREATE INDEX idx_user_name_email ON sys_user(username, email);

-- Rebuild index
ALTER TABLE sys_user ENGINE=InnoDB;

-- Analyze table
ANALYZE TABLE sys_user;
```

### 4.3 Query Optimization

**Optimization Suggestions**:

- Use EXPLAIN to analyze query plans
- Avoid SELECT *, only query needed fields
- Avoid using functions in WHERE clause
- Avoid performing operations on fields in WHERE clause
- Use LIMIT to restrict returned results
- Use JOIN reasonably to avoid Cartesian product

**Example**:

```sql
-- Bad query
SELECT * FROM sys_user WHERE DATE(create_time) = '2023-01-01';

-- Optimized query
SELECT id, username, email FROM sys_user WHERE create_time BETWEEN '2023-01-01 00:00:00' AND '2023-01-01 23:59:59';
```

### 4.4 Database Sharding

When the data volume reaches a certain scale, consider database sharding:

- **Horizontal Sharding**: Distribute data from the same table into multiple tables according to certain rules
- **Vertical Sharding**: Distribute fields of a table into multiple tables according to access frequency and size
- **Database Sharding**: Distribute data from different businesses into different databases

**Sharding Strategies**:

- Time-based sharding (e.g., by month)
- ID-based sharding (e.g., hash sharding)
- Business field-based sharding (e.g., by user ID)

## 5. Redis Optimization

### 5.1 Configuration Optimization

**Core configuration items**:

```ini
# /etc/redis.conf

# Basic configuration
bind 0.0.0.0
protected-mode yes
port 6379
daemonize yes
pidfile /var/run/redis_6379.pid
logfile /var/log/redis/redis.log

# Memory configuration
maxmemory 6G  # Recommended: 50%-70% of server memory
maxmemory-policy allkeys-lru  # Eviction policy when memory is insufficient

# Persistence configuration
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /var/lib/redis
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec  # Recommended: everysec for production environment

# Connection configuration
timeout 300
maxclients 10000

# Other configuration
tcp-keepalive 300
```

### 5.2 Cache Optimization

**Optimization Suggestions**:

- Set reasonable cache expiration time
- Avoid cache avalanche, cache breakdown, and cache penetration
- Use cache warming
- Regularly clean up expired cache
- Reasonably use Redis data structures

**Cache Avalanche Solutions**:

- Set random expiration time
- Use Redis cluster
- Implement cache degradation

**Cache Penetration Solutions**:

- Use Bloom filters
- Cache null values
- Rate limiting and circuit breaking

## 6. Security Configuration

### 6.1 Network Security

- Use firewall to limit access ports
- Configure VPN or dedicated line connection
- Use SSL/TLS for encrypted transmission
- Regular security scans
- Configure Intrusion Detection System (IDS)

### 6.2 Server Security

- Regularly update system and software packages
- Use strong passwords and key authentication
- Disable root remote login
- Configure sudo permissions
- Enable log auditing
- Regularly back up server configuration

### 6.3 Application Security

- Implement fine-grained permission control
- Encrypt sensitive data storage
- Prevent SQL injection
- Prevent XSS attacks
- Prevent CSRF attacks
- Implement API rate limiting and circuit breaking
- Regular code auditing

### 6.4 Data Security

- Regular database backups
- Implement data encryption
- Configure Access Control Lists (ACL)
- Data desensitization processing
- Implement data recovery mechanisms
- Regular data integrity checks

## 7. Monitoring and Logging

### 7.1 Monitoring System

It is recommended to use Prometheus + Grafana to build a monitoring system:

- **Prometheus**: Collect monitoring data
- **Grafana**: Visualize monitoring data
- **Node Exporter**: Monitor server metrics
- **JMX Exporter**: Monitor Java applications
- **MySQL Exporter**: Monitor MySQL database
- **Redis Exporter**: Monitor Redis

### 7.2 Log Management

- **ELK Stack**: Elasticsearch + Logstash + Kibana
- **Loki**: Lightweight log aggregation system
- **Filebeat**: Log collector

**Log Configuration Suggestions**:

- Unified log format
- Include necessary context information
- Implement log grading
- Regularly clean up expired logs
- Configure log alerts

## 8. Backup and Recovery

### 8.1 Database Backup

**Full Backup**:

```bash
# Use mysqldump for full backup
mysqldump -u root -p --all-databases --single-transaction --routines --triggers --events > /backup/mysql/full_backup_$(date +%Y%m%d_%H%M%S).sql

# Use xtrabackup for full backup
xtrabackup --backup --target-dir=/backup/mysql/full_backup_$(date +%Y%m%d_%H%M%S)
```

**Incremental Backup**:

```bash
# Use xtrabackup for incremental backup
xtrabackup --backup --target-dir=/backup/mysql/incremental_$(date +%Y%m%d_%H%M%S) --incremental-basedir=/backup/mysql/full_backup_20230101_000000
```

**Scheduled Backup Script**:

```bash
cat > /usr/local/bin/mysql_backup.sh << EOF
#!/bin/bash

BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)
FULL_BACKUP_DIR="$BACKUP_DIR/full_$DATE"

# Create backup directory
mkdir -p $FULL_BACKUP_DIR

# Execute full backup
mysqldump -u root -p"password" --all-databases --single-transaction --routines --triggers --events > $FULL_BACKUP_DIR/full_backup.sql

# Compress backup file
tar -czf $BACKUP_DIR/full_backup_$DATE.tar.gz -C $BACKUP_DIR full_$DATE

# Delete temporary directory
rm -rf $FULL_BACKUP_DIR

# Delete backups older than 7 days
find $BACKUP_DIR -name "full_backup_*.tar.gz" -mtime +7 -delete
EOF

# Add to crontab
chmod +x /usr/local/bin/mysql_backup.sh
echo "0 2 * * * /usr/local/bin/mysql_backup.sh" >> /var/spool/cron/root
```

### 8.2 Application Backup

**Example**:

```bash
# Backup application configuration and data
BACKUP_DIR="/backup/app"
DATE=$(date +%Y%m%d_%H%M%S)
mkdir -p $BACKUP_DIR/$DATE

# Backup configuration files
cp -r /opt/tagtag/backend/config $BACKUP_DIR/$DATE/

# Backup logs (optional)
cp -r /opt/tagtag/backend/logs $BACKUP_DIR/$DATE/

# Backup static resources
cp -r /usr/share/nginx/html/tagtag $BACKUP_DIR/$DATE/

# Compress backup file
tar -czf $BACKUP_DIR/app_backup_$DATE.tar.gz -C $BACKUP_DIR $DATE

# Delete temporary directory
rm -rf $BACKUP_DIR/$DATE

# Delete backups older than 7 days
find $BACKUP_DIR -name "app_backup_*.tar.gz" -mtime +7 -delete
```

## 9. Performance Testing

### 9.1 Load Testing Tools

- **JMeter**: Powerful load testing tool
- **Gatling**: High-performance load testing tool based on Scala
- **k6**: Modern load testing tool
- **Apache Benchmark (ab)**: Simple and easy-to-use HTTP load testing tool

### 9.2 Testing Scenarios

- **Concurrent Testing**: Test system performance under different concurrency numbers
- **Stress Testing**: Test system limit performance
- **Stability Testing**: Long-term operation test to check system stability
- **Capacity Testing**: Test system maximum capacity

**JMeter Testing Example**:

1. Create a test plan
2. Add thread group
3. Add HTTP request
4. Add listeners (such as aggregate report, graph results)
5. Run the test
6. Analyze results

## 10. Common Issues and Solutions

### 10.1 Application Startup Failure

**Problem**: Application exits immediately after startup

**Solution**:

```bash
# Check logs
cat /opt/tagtag/backend/logs/application.log

# Check port occupancy
netstat -tlnp | grep 8080

# Check database connection
telnet mysql-server 3306

# Check Redis connection
telnet redis-server 6379
```

### 10.2 Database Connection Failure

**Problem**: Application cannot connect to the database

**Solution**:

```bash
# Check database service status
systemctl status mysqld

# Check database user permissions
mysql -u root -p -e "SHOW GRANTS FOR 'tagtag'@'%';"

# Check firewall settings
firewall-cmd --list-ports

# Check SELinux settings
getenforce
```

### 10.3 Frontend Page Cannot Be Accessed

**Problem**: Accessing the frontend page shows 404 or blank page

**Solution**:

```bash
# Check Nginx configuration
nginx -t

# Check Nginx logs
cat /var/log/nginx/tagtag.error.log

# Check static file permissions
ls -la /usr/share/nginx/html/tagtag/

# Check frontend routing configuration
# Ensure Nginx is configured with try_files $uri $uri/ /index.html;
```

## 11. Summary

Production environment deployment is a complex process that involves server configuration, application deployment, database optimization, security configuration, monitoring logging, and backup recovery. This document provides a detailed guide for deploying the Tagtag project in a production environment, hoping to help you successfully complete the deployment work.

In the actual deployment process, it is recommended to flexibly adjust configuration parameters according to your business needs and server resources to ensure high performance, high availability, and high security of the system.