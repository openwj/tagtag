## 目标

- 将登录/认证相关代码统一使用项目通用的 `BusinessException`，使全局异常处理一致、可控并返回统一错误码/消息。
- 确保请求 DTO 的字段校验通过标准的 Bean Validation（即使用 `spring-boot-starter-validation` + `jakarta.validation` 注解）完成，并由全局异常处理返回统一错误响应。

## 问题诊断（简要）

- 当前 `AuthServiceImpl` 在校验用户名/密码、用户不存在、密码错误等情况直接抛出 `IllegalArgumentException`（或其他运行时异常），这会被全局异常处理按通用 500/未知逻辑处理，不利于返回明确业务错误码。
- 控制器端的字段非空校验使用了 `jakarta.validation` 注解，但项目中可能没有明确引入 `spring-boot-starter-validation` 依赖（需确认），且有些地方可能没有在方法参数上添加 `@Valid`。

## 方案概览

1. 将服务层所有用于业务错误的 `throw new IllegalArgumentException(...)` 改成 `throw BusinessException.of(ErrorCode.XXX, ...)`（或类似工厂方法），以便全局异常处理器 `GlobalExceptionHandler` 使用 `ex.getHttpStatus()` 与 `ex.getErrorCode()` 统一处理并返回标准 `Result`。
2. 确认或添加 `spring-boot-starter-validation` 依赖到有 Controller 的模块（例如 `tagtag-module-auth/pom.xml` 或父 POM），并统一使用 `jakarta.validation.constraints.*` 注解在请求 DTO 上（已大量使用）。
3. 确保控制器的入参使用 `@Valid`（例如 `login(@Valid @RequestBody LoginRequest req)`），并且 `GlobalExceptionHandler` 中对 `MethodArgumentNotValidException`/`BindException` 的处理已存在且返回明确错误码（当前已有处理）。
4. 增加单元/集成测试覆盖：模拟非法登录参数、用户不存在、密码错误，验证返回的 HTTP 状态与 JSON 错误码为预期。

## 逐步实施计划（每步可独立回滚）

### 步骤 1 — 审查并替换异常
- 目标文件：
  - `tagtag-module/tagtag-module-auth/src/main/java/dev/tagtag/module/auth/service/impl/AuthServiceImpl.java`
  - 可能的其他抛 `IllegalArgumentException` 的类（通过全局 grep 查找 `throw new IllegalArgumentException`）。
- 修改要点：把 `throw new IllegalArgumentException("消息")` 替换为：
  - `throw BusinessException.of(ErrorCode.INVALID_ARGUMENT, "消息")`（或更合适的 `ErrorCode`，按项目已有枚举选择），并在必要时带上参数。
- 理由：`BusinessException` 被 `GlobalExceptionHandler` 专门处理，能返回统一的 `Result.fail(...)` 与相应 HTTP 状态。

### 步骤 2 — 确保 DTO 与控制器使用 Bean Validation
- 检查文件：
  - `tagtag-module/tagtag-module-auth/src/main/java/dev/tagtag/module/auth/controller/AuthController.java`（确保方法参数带 `@Valid`）
  - DTO：`LoginRequest`（确保字段上有 `@NotBlank` / `@Size` 等注解）
- 如果缺失：在相应位置添加 `@Valid` 与必要的注解。

### 步骤 3 — 引入/确认 `spring-boot-starter-validation` 依赖
- 在需要的模块 POM 添加依赖（优先在模块 POM `tagtag-module-auth/pom.xml`）：
  ```xml
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
  </dependency>
  ```
- 理由：Spring Boot Starter 会自动配置 `LocalValidatorFactoryBean`，使 `@Valid` 生效并将校验异常转换为 `MethodArgumentNotValidException`。

### 步骤 4 — 更新 GlobalExceptionHandler（如需）
- 检查 `tagtag-framework/src/main/java/dev/tagtag/framework/web/GlobalExceptionHandler.java`：
  - `@ExceptionHandler(BusinessException.class)` 必须返回包含 `ex.getErrorCode()` 与 `ex.getMessage()` 的标准 `Result`，并设置合适 HTTP 状态。
  - `@ExceptionHandler(MethodArgumentNotValidException.class)` 与 `BindException` 已存在，但请确认 HTTP 状态与 `ErrorCode`（如 `UNPROCESSABLE_ENTITY`）是否与你希望的一致。
- 如需微调，修改错误消息聚合逻辑以返回第一个字段错误或把错误字段列表作为响应的一部分。

### 步骤 5 — 添加测试
- 编写单元/集成测试：
  - 登录接口：空用户名/密码 → 断言返回 422 或指定业务错误码；
  - 用户不存在 → 断言返回 4xx 且错误码为 `USER_NOT_FOUND`；
  - 密码错误 → 返回指定错误码。
- 测试所在模块：`tagtag-module-auth`（可用 SpringBootTest 或 MockMvc）。

### 步骤 6 — 本地验证与部署注意事项
- 本地使用 `dev` profile 启动，运行测试并用 Postman/HTTPie 调用登录接口检查返回。
- 生产环境切勿启用 `dev` 特有的清库逻辑或把调试信息暴露给外界。

## 验证标准
- 登录失败时，接口返回统一 JSON 结构：`{code: <错误码>, message: <可展示消息>, data: null}`。
- 不再抛出 `IllegalArgumentException` 导致的非业务（500）响应；而是返回明确定义的业务错误码与 HTTP 状态。
- `@Valid` 生效，字段非空/格式错误会被 `GlobalExceptionHandler` 捕获并返回明确错误信息。
- 新增测试全部通过。

## 风险与回滚
- 风险：错误选择 ErrorCode 会导致前端无法正确识别错误类型。回滚方案：把修改的 `throw BusinessException...` 改回原始异常并回退提交。

## 预计修改的文件（清单）
- `tagtag-module/tagtag-module-auth/src/main/java/.../AuthServiceImpl.java`（替换异常）
- `tagtag-module/tagtag-module-auth/src/main/java/.../AuthController.java`（确认 `@Valid`）
- `tagtag-module/tagtag-module-auth/pom.xml`（添加 `spring-boot-starter-validation`，如缺失）
- `tagtag-framework/src/main/java/dev/tagtag/framework/web/GlobalExceptionHandler.java`（微调返回结构/状态，可选）
- 测试文件：`tagtag-module/tagtag-module-auth/src/test/.../AuthControllerTest.java`

---

请确认是否按此计划执行（我会在你确认后开始修改代码并运行验证），或告诉我你希望调整的 ErrorCode 映射或返回的 HTTP 状态策略。