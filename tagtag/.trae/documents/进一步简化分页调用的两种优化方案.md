## 目标
- 将 `var args = Pages.toPageAndOrder(...)` 简化为更短、更直观的一行或两行写法，减少样板代码与噪音。

## 方案 A：一行式调用（函数式封装）
- 新增工具方法：
```java
/**
 * 一行完成分页与 ORDER BY 构建，并调用 Mapper 的 selectPage
 * mapperFn 接收 Page 与 orderBySql，返回 IPage
 */
public static <T, Q> IPage<T> selectPage(
    BiFunction<Page<T>, String, IPage<T>> mapperFn,
    Q query,
    PageQuery pageQuery,
    PageProperties props,
    Class<T> entityClass,
    Collection<String> whitelist
)
```
- 使用示例（Role）：
```java
IPage<Role> page = Pages.selectPage(
    (page, orderBy) -> baseMapper.selectPage(page, query, orderBy),
    query,
    pageQuery,
    pageProperties,
    Role.class,
    pageProperties.getRole()
);
```
- 优点：服务层一行完成；无 var、中间变量与默认参数噪音。
- 缺点：引入函数式接口使用，代码风格更“FP”，团队需要接受度；调试时中间值不可见。

## 方案 B：record + 简短访问器（两行但更清爽）
- 将 `Pages.PageOrder<T>` 改为 `record PageOrder<T>(Page<T> page, String orderBySql)`
- 使用示例（Role）：
```java
var po = Pages.toPageAndOrder(pageQuery, pageProperties, Role.class, pageProperties.getRole());
IPage<Role> page = baseMapper.selectPage(po.page(), query, po.orderBySql());
```
- 优点：保留中间值可视化，访问器简短，无 get 前缀；比当前更清爽。
- 缺点：仍需两行；不如方案 A 的“一步到位”。

## 推荐
- 若追求最简洁：选方案 A（一行式）。
- 若偏好可读与可调试：选方案 B（record）。

## 兼容与风险
- 两方案都沿用现有 PageNormalizer 与实体元数据解析，不改变行为；编译风险低。
- 方案 A 在使用 lambda 时，注意 IDE 友好性与断点调试；方案 B 需 Java 16+ 支持 record。

## 交付
- 我将按你选择的方案实现对应工具方法或 record，并替换四个服务的调用，完成编译与冒烟验证。